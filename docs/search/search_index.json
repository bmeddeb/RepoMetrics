{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GitFleet","text":"<p>GitFleet is a high-performance Git operations library with Python bindings, powered by Rust. It provides efficient repository management, blame analysis, commit extraction, and integration with Git hosting providers.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>High-Performance Core: Core operations implemented in Rust for maximum speed</li> <li>Asynchronous API: All repository operations are non-blocking using asyncio</li> <li>Git Provider Integration: Support for GitHub APIs with GitLab and BitBucket coming soon</li> <li>Pydantic Models: Strong validation and serialization for all data</li> <li>Token Management: Automatic token rotation and rate limit handling</li> <li>Pandas Integration: Convert results to DataFrames for analysis</li> </ul>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>GitFleet uses a hybrid architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Python Interface     \u2502   User-friendly API, asyncio integration\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   PyO3 Bridge Layer    \u2502   Seamless Rust-Python interoperability\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Rust Core Library    \u2502   High-performance Git operations\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#main-components","title":"\ud83d\udccb Main Components","text":""},{"location":"#core-repository-operations","title":"Core Repository Operations","text":"<ul> <li>Repository Manager: Main interface for managing repositories</li> <li>Clone Operations: Non-blocking repository cloning with progress tracking</li> <li>Blame Analysis: Extract and analyze blame information</li> <li>Commit Extraction: Analyze commit history and statistics</li> </ul>"},{"location":"#provider-api-clients","title":"Provider API Clients","text":"<ul> <li>GitHub Client: Complete API client for GitHub</li> <li>Token Manager: Token rotation and rate limit handling</li> <li>Provider Models: Type-safe models for all provider data</li> </ul>"},{"location":"#installation","title":"\ud83d\udd27 Installation","text":"<pre><code>pip install gitfleet\n</code></pre> <p>See the Installation Guide for detailed instructions.</p>"},{"location":"#quick-start","title":"\ud83d\udea6 Quick Start","text":"<pre><code>import asyncio\nfrom GitFleet import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Clone repositories\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a cloned repository\n    repo_path = next(\n        (task.temp_dir for task in tasks.values() \n         if task.status.status_type == \"completed\"),\n        None\n    )\n\n    if repo_path:\n        # Analyze blame\n        blame = await repo_manager.bulk_blame(\n            repo_path, [\"README.md\"]\n        )\n\n        # Extract commits\n        commits = await repo_manager.extract_commits(repo_path)\n\n    # Clean up\n    await repo_manager.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>See the Basic Usage Example for a more complete example.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Installation: Detailed installation instructions</li> <li>API Reference: Core API documentation</li> <li>Provider APIs: Git provider API clients</li> <li>Examples: Code examples for various use cases</li> <li>Advanced: Performance tips and advanced usage</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! See the Contributing Guide for details.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>GitFleet is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"CloneStatus/","title":"CloneStatus","text":"<p>The <code>CloneStatus</code> class represents the current status of a repository cloning operation. It is used to track the progress and outcome of cloning tasks managed by <code>RepoManager</code> and is typically accessed as the <code>status</code> field of a <code>CloneTask</code> object.</p>"},{"location":"CloneStatus/#fields","title":"Fields","text":"<ul> <li><code>status_type</code> (<code>str</code>): The type of status. Possible values are:</li> <li><code>'queued'</code>: The cloning task is waiting to start.</li> <li><code>'cloning'</code>: The repository is currently being cloned. See <code>progress</code> for completion percentage.</li> <li><code>'completed'</code>: The repository has been successfully cloned.</li> <li><code>'failed'</code>: The cloning operation failed. See <code>error</code> for details.</li> <li><code>progress</code> (<code>Optional[int]</code>): The percentage of completion (0-100) if the task is currently cloning, or <code>None</code> otherwise.</li> <li><code>error</code> (<code>Optional[str]</code>): An error message if the cloning operation failed, or <code>None</code> otherwise.</li> </ul>"},{"location":"CloneStatus/#typical-usage","title":"Typical Usage","text":"<p>You will most often encounter <code>CloneStatus</code> as part of a <code>CloneTask</code> when checking the status of repository cloning operations.</p>"},{"location":"CloneStatus/#example-checking-the-status-of-a-clonetask","title":"Example: Checking the Status of a CloneTask","text":"<pre><code>import asyncio\nfrom RepoMetrics import RepoManager\n\nasync def main():\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, \"username\", \"token\")\n    await manager.clone_all()\n    clone_tasks = await manager.fetch_clone_tasks()\n    for url, task in clone_tasks.items():\n        status = task.status\n        print(f\"Repo: {url}\")\n        print(f\"  Status: {status.status_type}\")\n        if status.status_type == \"cloning\":\n            print(f\"  Progress: {status.progress}%\")\n        if status.status_type == \"failed\":\n            print(f\"  Error: {status.error}\")\n\nasyncio.run(main())\n</code></pre> <p>The <code>CloneStatus</code> class helps you monitor and react to the state of repository cloning operations in your workflow.</p> <p>Detailed documentation coming soon.</p>"},{"location":"CloneTask/","title":"CloneTask","text":"<p>The <code>CloneTask</code> class represents a repository cloning task and its current status. It is typically used to track the progress and results of repository cloning operations managed by <code>RepoManager</code>.</p> <p>A <code>CloneTask</code> object is returned by methods such as <code>RepoManager.fetch_clone_tasks()</code>, which provides a mapping from repository URLs to their associated <code>CloneTask</code>.</p>"},{"location":"CloneTask/#fields","title":"Fields","text":"<ul> <li><code>url</code> (<code>str</code>): The URL of the repository being cloned.</li> <li><code>status</code> (<code>CloneStatus</code>): The current status of the cloning operation (see the <code>CloneStatus</code> documentation for details).</li> <li><code>temp_dir</code> (<code>Optional[str]</code>): The path to the temporary directory where the repository was cloned, or <code>None</code> if cloning has not completed or failed.</li> </ul>"},{"location":"CloneTask/#typical-usage","title":"Typical Usage","text":"<p>You do not create <code>CloneTask</code> objects directly. Instead, you receive them from <code>RepoManager</code> methods, most commonly from <code>fetch_clone_tasks()</code>.</p>"},{"location":"CloneTask/#example-checking-clone-statuses","title":"Example: Checking Clone Statuses","text":"<pre><code>import asyncio\nfrom RepoMetrics import RepoManager\n\nasync def main():\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, \"username\", \"token\")\n    await manager.clone_all()\n    clone_tasks = await manager.fetch_clone_tasks()\n    for url, task in clone_tasks.items():\n        print(f\"Repo: {url}\")\n        print(f\"  Status: {task.status.status_type}\")\n        print(f\"  Temp dir: {task.temp_dir}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"CloneTask/#example-using-temp_dir-for-further-operations","title":"Example: Using temp_dir for Further Operations","text":"<p>After cloning, you can use the <code>temp_dir</code> field of a <code>CloneTask</code> to perform further operations, such as blame or commit extraction:</p> <pre><code># ... after fetching clone_tasks ...\nfor url, task in clone_tasks.items():\n    if task.temp_dir:\n        blame = await manager.bulk_blame(task.temp_dir, [\"main.py\"])\n        print(f\"Blame for {url}: {blame}\")\n</code></pre> <p>For details on the <code>status</code> field, see the CloneStatus documentation.</p>"},{"location":"GitFleetAPI/","title":"GitFleet Library Public API","text":"<p>This document provides a comprehensive reference for all classes, methods, and functions available to users of the GitFleet library.</p>"},{"location":"GitFleetAPI/#repository-management-rust-powered","title":"Repository Management (Rust-powered)","text":""},{"location":"GitFleetAPI/#repomanager","title":"RepoManager","text":"<p>Core class for managing Git repositories: - <code>__init__(urls: List[str], github_username: str, github_token: str)</code> - Initialize with repository URLs and credentials - <code>clone_all() -&gt; None</code> - Asynchronously clone all repositories - <code>fetch_clone_tasks() -&gt; Dict[str, CloneTask]</code> - Get status of all clone operations - <code>clone(url: str) -&gt; None</code> - Clone a single repository - <code>bulk_blame(repo_path: str, file_paths: List[str]) -&gt; Dict[str, Any]</code> - Perform git blame on multiple files - <code>extract_commits(repo_path: str) -&gt; List[Dict[str, Any]]</code> - Extract commit history - <code>cleanup() -&gt; Dict[str, Union[bool, str]]</code> - Clean up temporary directories</p>"},{"location":"GitFleetAPI/#clonetask","title":"CloneTask","text":"<p>Represents a repository cloning task: - Properties: <code>url</code>, <code>status</code>, <code>temp_dir</code> - <code>model_dump() -&gt; Dict[str, Any]</code> - Convert to dictionary - <code>model_dump_json(indent: Optional[int] = None) -&gt; str</code> - Convert to JSON string - <code>model_validate(obj: Any) -&gt; CloneTask</code> - Create from dictionary/object</p>"},{"location":"GitFleetAPI/#clonestatus","title":"CloneStatus","text":"<p>Represents the status of a cloning operation: - Properties: <code>status_type</code>, <code>progress</code>, <code>error</code> - <code>model_dump() -&gt; Dict[str, Any]</code> - Convert to dictionary - <code>model_dump_json(indent: Optional[int] = None) -&gt; str</code> - Convert to JSON string - <code>model_validate(obj: Any) -&gt; CloneStatus</code> - Create from dictionary/object</p>"},{"location":"GitFleetAPI/#clonestatustype","title":"CloneStatusType","text":"<p>Enum for clone status: - <code>QUEUED</code> - Task is waiting to start - <code>CLONING</code> - Task is in progress - <code>COMPLETED</code> - Task completed successfully - <code>FAILED</code> - Task failed</p>"},{"location":"GitFleetAPI/#provider-clients","title":"Provider Clients","text":""},{"location":"GitFleetAPI/#githubclient","title":"GitHubClient","text":"<p>Client for GitHub API: - <code>__init__(token: str, base_url: Optional[str] = None, token_manager: Optional[TokenManager] = None, use_python_impl: bool = False)</code> - <code>fetch_repositories(owner: str) -&gt; List[RepoInfo]</code> - Get repositories for owner - <code>fetch_user_info() -&gt; UserInfo</code> - Get authenticated user info - <code>get_rate_limit() -&gt; RateLimitInfo</code> - Get API rate limit info - <code>fetch_repository_details(owner: str, repo: str) -&gt; RepoDetails</code> - Get detailed repo info - <code>fetch_contributors(owner: str, repo: str) -&gt; List[ContributorInfo]</code> - Get repo contributors - <code>fetch_branches(owner: str, repo: str) -&gt; List[BranchInfo]</code> - Get repo branches - <code>validate_credentials() -&gt; bool</code> - Check if credentials are valid</p>"},{"location":"GitFleetAPI/#gitproviderclient","title":"GitProviderClient","text":"<p>Abstract base class for Git provider clients: - <code>__init__(provider_type: ProviderType)</code> - Initialize with provider type - Abstract methods implemented by concrete clients (see GitHubClient) - <code>to_pandas(data: Union[List[Any], Any]) -&gt; pandas.DataFrame</code> - Convert data to DataFrame</p>"},{"location":"GitFleetAPI/#providertype","title":"ProviderType","text":"<p>Enum for Git provider types: - <code>GITHUB</code> - GitHub provider - <code>GITLAB</code> - GitLab provider - <code>BITBUCKET</code> - BitBucket provider</p>"},{"location":"GitFleetAPI/#data-models","title":"Data Models","text":""},{"location":"GitFleetAPI/#userinfo","title":"UserInfo","text":"<p>User information from Git providers: - Properties: <code>id</code>, <code>login</code>, <code>name</code>, <code>email</code>, <code>avatar_url</code>, <code>provider_type</code>, <code>raw_data</code> - <code>model_dump() -&gt; Dict[str, Any]</code> - Serialize to dict - <code>model_dump_json(indent: Optional[int] = None) -&gt; str</code> - Serialize to JSON - <code>model_validate(obj: Any) -&gt; UserInfo</code> - Create from dict/object</p>"},{"location":"GitFleetAPI/#repoinfo","title":"RepoInfo","text":"<p>Basic repository information: - Properties: <code>name</code>, <code>full_name</code>, <code>clone_url</code>, <code>description</code>, <code>default_branch</code>, <code>created_at</code>, <code>updated_at</code>, <code>language</code>, <code>fork</code>, <code>forks_count</code>, <code>stargazers_count</code>, <code>provider_type</code>, <code>visibility</code>, <code>owner</code>, <code>raw_data</code> - <code>created_datetime() -&gt; Optional[datetime]</code> - Parse created_at as datetime - <code>updated_datetime() -&gt; Optional[datetime]</code> - Parse updated_at as datetime - <code>model_dump() -&gt; Dict[str, Any]</code> - Serialize to dict - <code>model_dump_json(indent: Optional[int] = None) -&gt; str</code> - Serialize to JSON - <code>model_validate(obj: Any) -&gt; RepoInfo</code> - Create from dict/object</p>"},{"location":"GitFleetAPI/#repodetails","title":"RepoDetails","text":"<p>Detailed repository information (extends RepoInfo): - Additional properties: <code>topics</code>, <code>license</code>, <code>homepage</code>, <code>has_wiki</code>, <code>has_issues</code>, <code>has_projects</code>, <code>archived</code>, <code>pushed_at</code>, <code>size</code> - <code>pushed_datetime() -&gt; Optional[datetime]</code> - Parse pushed_at as datetime - All methods from RepoInfo</p>"},{"location":"GitFleetAPI/#ratelimitinfo","title":"RateLimitInfo","text":"<p>API rate limit information: - Properties: <code>limit</code>, <code>remaining</code>, <code>reset_time</code>, <code>used</code>, <code>provider_type</code> - <code>seconds_until_reset() -&gt; int</code> - Get seconds until rate limit resets - <code>model_dump() -&gt; Dict[str, Any]</code> - Serialize to dict - <code>model_dump_json(indent: Optional[int] = None) -&gt; str</code> - Serialize to JSON - <code>model_validate(obj: Any) -&gt; RateLimitInfo</code> - Create from dict/object</p>"},{"location":"GitFleetAPI/#branchinfo","title":"BranchInfo","text":"<p>Git branch information: - Properties: <code>name</code>, <code>commit_sha</code>, <code>protected</code>, <code>provider_type</code>, <code>raw_data</code> - <code>model_dump() -&gt; Dict[str, Any]</code> - Serialize to dict - <code>model_dump_json(indent: Optional[int] = None) -&gt; str</code> - Serialize to JSON - <code>model_validate(obj: Any) -&gt; BranchInfo</code> - Create from dict/object</p>"},{"location":"GitFleetAPI/#contributorinfo","title":"ContributorInfo","text":"<p>Repository contributor information: - Properties: <code>id</code>, <code>login</code>, <code>contributions</code>, <code>avatar_url</code>, <code>provider_type</code>, <code>raw_data</code> - <code>model_dump() -&gt; Dict[str, Any]</code> - Serialize to dict - <code>model_dump_json(indent: Optional[int] = None) -&gt; str</code> - Serialize to JSON - <code>model_validate(obj: Any) -&gt; ContributorInfo</code> - Create from dict/object</p>"},{"location":"GitFleetAPI/#token-management","title":"Token Management","text":""},{"location":"GitFleetAPI/#tokenmanager","title":"TokenManager","text":"<p>Manages API tokens and rate limits: - <code>__init__(max_retries: int = 3)</code> - Initialize with retry count - <code>add_token(token: str, provider_type: ProviderType) -&gt; None</code> - Add token - <code>get_next_available_token(provider_type: ProviderType) -&gt; Optional[TokenInfo]</code> - Get available token - <code>update_rate_limit(token: str, provider_type: ProviderType, remaining: int, reset_time: int) -&gt; None</code> - Update limits - <code>mark_token_invalid(token: str, provider_type: ProviderType) -&gt; None</code> - Mark token as invalid - <code>get_all_tokens(provider_type: Optional[ProviderType] = None) -&gt; List[TokenInfo]</code> - Get all tokens</p>"},{"location":"GitFleetAPI/#tokeninfo","title":"TokenInfo","text":"<p>Information about an API token: - Properties: <code>token</code>, <code>provider_type</code>, <code>remaining</code>, <code>reset_time</code>, <code>status</code> - <code>secret_token</code> - Property that returns token as SecretStr for secure handling</p>"},{"location":"GitFleetAPI/#authentication-and-security","title":"Authentication and Security","text":""},{"location":"GitFleetAPI/#credentialmanager","title":"CredentialManager","text":"<p>Manages and securely stores credentials: - <code>__init__(encryption_key: Optional[str] = None, use_encryption: bool = True)</code> - Initialize - <code>add_credential(provider_type: ProviderType, token: str, username: Optional[str] = None, email: Optional[str] = None) -&gt; None</code> - Add credential - <code>get_credential(provider_type: ProviderType) -&gt; Optional[CredentialEntry]</code> - Get credential - <code>list_credentials() -&gt; List[CredentialEntry]</code> - List all credentials - <code>remove_credential(provider_type: ProviderType) -&gt; bool</code> - Remove credential - <code>save_to_file(file_path: str) -&gt; None</code> - Save credentials to file - <code>load_from_file(file_path: str) -&gt; None</code> - Load credentials from file - <code>clear_all() -&gt; None</code> - Clear all credentials</p>"},{"location":"GitFleetAPI/#utility-functions","title":"Utility Functions","text":""},{"location":"GitFleetAPI/#data-conversion","title":"Data Conversion","text":"<ul> <li><code>to_dataframe(data: Union[List[Dict[str, Any]], Dict[str, Any], List[Any], BaseModel, List[BaseModel]]) -&gt; pandas.DataFrame</code> - Convert to pandas DataFrame</li> <li><code>flatten_dataframe(df: pandas.DataFrame, separator: str = \"_\") -&gt; pandas.DataFrame</code> - Flatten nested DataFrame columns</li> <li><code>to_json(obj: Any, indent: Optional[int] = None) -&gt; str</code> - Convert object to JSON string</li> <li><code>to_dict(obj: Any) -&gt; Dict[str, Any]</code> - Convert object to dictionary</li> </ul>"},{"location":"GitFleetAPI/#rate-limiting","title":"Rate Limiting","text":"<ul> <li><code>RateLimiter</code> - Class for rate limiting API calls</li> <li><code>__init__(requests_per_second: float)</code> - Initialize with rate limit</li> <li><code>acquire() -&gt; None</code> - Acquire a token (blocks if rate exceeded)</li> <li><code>try_acquire() -&gt; bool</code> - Try to acquire a token (non-blocking)</li> </ul>"},{"location":"GitFleetAPI/#rust-type-conversion","title":"Rust Type Conversion","text":"<ul> <li><code>clone_status_to_pydantic(rust_status: RustCloneStatus) -&gt; CloneStatus</code> - Convert Rust CloneStatus to Pydantic model</li> <li><code>clone_task_to_pydantic(rust_task: RustCloneTask) -&gt; CloneTask</code> - Convert Rust CloneTask to Pydantic model</li> </ul>"},{"location":"GitFleetAPI/#package-structure","title":"Package Structure","text":"<p>The library is organized into several subpackages: - <code>GitFleet</code> - Main package - <code>GitFleet.models</code> - Data models - <code>GitFleet.providers</code> - Git provider clients - <code>GitFleet.utils</code> - Utility functions and classes</p>"},{"location":"GitFleetAPI/#optional-features","title":"Optional Features","text":"<p>The library has several optional features that can be installed: - <code>pydantic</code> - Enhanced validation and serialization - <code>pandas</code> - Data analysis and DataFrame support - <code>crypto</code> - Secure credential encryption</p> <p>Install with extras like: <code>pip install \"gitfleet[pydantic,pandas]\"</code></p>"},{"location":"RepoManager/","title":"RepoManager","text":"<p>The <code>RepoManager</code> class is the main interface for managing multiple Git repositories, performing high-performance clone operations, running blame analysis, and extracting commit history. It is designed for asynchronous use, allowing you to efficiently manage and analyze many repositories in parallel.</p> <p>Note: All major methods of <code>RepoManager</code> are asynchronous and should be awaited. You can use Python's <code>asyncio</code> or any compatible event loop to run these methods.</p>"},{"location":"RepoManager/#overview","title":"Overview","text":"<ul> <li>Manage a set of repositories (clone, track status, cleanup)</li> <li>Perform bulk blame operations on files</li> <li>Extract commit history from repositories</li> <li>All operations are designed to be non-blocking and scalable</li> </ul>"},{"location":"RepoManager/#initialization","title":"Initialization","text":"<pre><code>from RepoMetrics import RepoManager\n\n# List of repository URLs to manage\nurls = [\n    \"https://github.com/owner/repo1.git\",\n    \"https://github.com/owner/repo2.git\",\n]\n\n# Create a RepoManager instance\nmanager = RepoManager(urls, github_username=\"your-username\", github_token=\"your-token\")\n</code></pre>"},{"location":"RepoManager/#methods","title":"Methods","text":""},{"location":"RepoManager/#clone_all","title":"clone_all()","text":"<p>Clones all repositories configured in this manager instance asynchronously.</p> <pre><code>await manager.clone_all()\n</code></pre>"},{"location":"RepoManager/#fetch_clone_tasks","title":"fetch_clone_tasks()","text":"<p>Fetches the current status of all cloning tasks asynchronously. Returns a dictionary mapping repository URLs to <code>CloneTask</code> objects, which include a <code>CloneStatus</code>.</p> <pre><code>clone_tasks = await manager.fetch_clone_tasks()\nfor url, task in clone_tasks.items():\n    print(url, task.status.status_type)\n</code></pre>"},{"location":"RepoManager/#cloneurl","title":"clone(url)","text":"<p>Clones a single repository specified by URL asynchronously.</p> <pre><code>await manager.clone(\"https://github.com/owner/repo3.git\")\n</code></pre>"},{"location":"RepoManager/#bulk_blamerepo_path-file_paths","title":"bulk_blame(repo_path, file_paths)","text":"<p>Performs 'git blame' on multiple files within a cloned repository asynchronously. Returns a dictionary mapping file paths to blame results.</p> <pre><code>blame_results = await manager.bulk_blame(\"/path/to/repo\", [\"file1.py\", \"file2.py\"])\nfor file, lines in blame_results.items():\n    print(f\"Blame for {file}:\", lines)\n</code></pre>"},{"location":"RepoManager/#extract_commitsrepo_path","title":"extract_commits(repo_path)","text":"<p>Extracts commit data from a cloned repository asynchronously. Returns a list of commit dictionaries.</p> <pre><code>commits = await manager.extract_commits(\"/path/to/repo\")\nprint(f\"Found {len(commits)} commits.\")\n</code></pre>"},{"location":"RepoManager/#cleanup","title":"cleanup()","text":"<p>Cleans up all temporary directories created for cloned repositories. Returns a dictionary with repository URLs as keys and cleanup results as values (True for success, or an error message).</p> <pre><code>cleanup_results = manager.cleanup()\nfor url, result in cleanup_results.items():\n    print(f\"Cleanup for {url}: {result}\")\n</code></pre>"},{"location":"RepoManager/#simple-example","title":"Simple Example","text":"<pre><code>import asyncio\nfrom RepoMetrics import RepoManager\n\nasync def main():\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, \"username\", \"token\")\n    await manager.clone_all()\n    tasks = await manager.fetch_clone_tasks()\n    print(tasks)\n    await manager.bulk_blame(\"/path/to/repo\", [\"file1.py\"])\n    await manager.extract_commits(\"/path/to/repo\")\n    manager.cleanup()\n\nasyncio.run(main())\n</code></pre>"},{"location":"RepoManager/#advanced-example-managing-multiple-repositories","title":"Advanced Example: Managing Multiple Repositories","text":"<pre><code>import asyncio\nfrom RepoMetrics import RepoManager\n\nasync def main():\n    urls = [\n        \"https://github.com/owner/repo1.git\",\n        \"https://github.com/owner/repo2.git\",\n        \"https://github.com/owner/repo3.git\",\n    ]\n    manager = RepoManager(urls, \"username\", \"token\")\n    await manager.clone_all()\n    clone_tasks = await manager.fetch_clone_tasks()\n    for url, task in clone_tasks.items():\n        print(f\"{url}: {task.status.status_type}\")\n    # Run blame on all files in all repos (example)\n    for url, task in clone_tasks.items():\n        if task.temp_dir:\n            blame = await manager.bulk_blame(task.temp_dir, [\"main.py\", \"utils.py\"])\n            print(f\"Blame for {url}: {blame}\")\n    # Extract commits\n    for url, task in clone_tasks.items():\n        if task.temp_dir:\n            commits = await manager.extract_commits(task.temp_dir)\n            print(f\"Commits for {url}: {len(commits)} found.\")\n    # Cleanup\n    results = manager.cleanup()\n    print(\"Cleanup results:\", results)\n\nasyncio.run(main())\n</code></pre> <p>For details on <code>CloneTask</code> and <code>CloneStatus</code>, see their respective documentation pages.</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>GitFleet is a Python package with Rust components that provides Git repository analysis and API clients. This guide covers how to install GitFleet and its dependencies.</p>"},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>Install GitFleet from PyPI:</p> <pre><code>pip install gitfleet\n</code></pre> <p>This installs GitFleet with minimal dependencies required for core functionality.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.10 or higher</li> <li>Rust: If you're building from source, you'll need a Rust toolchain (rustc, cargo)</li> </ul>"},{"location":"installation/#installation-options","title":"Installation Options","text":"<p>GitFleet follows the optional dependencies pattern, allowing you to install only what you need:</p>"},{"location":"installation/#full-installation-all-features","title":"Full Installation (All Features)","text":"<pre><code>pip install \"gitfleet[all]\"\n</code></pre>"},{"location":"installation/#feature-specific-installation","title":"Feature-specific Installation","text":"<p>Choose only the features you need:</p> <pre><code># For data analysis with pandas\npip install \"gitfleet[pandas]\"\n\n# For secure token encryption\npip install \"gitfleet[crypto]\"\n\n# For pydantic integration (future use)\npip install \"gitfleet[pydantic]\"\n\n# For development (linting, testing, etc.)\npip install \"gitfleet[dev]\"\n\n# Multiple features can be combined\npip install \"gitfleet[pandas,crypto]\"\n</code></pre>"},{"location":"installation/#dependencies-explained","title":"Dependencies Explained","text":""},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>httpx: Required for API clients to communicate with Git provider APIs</li> </ul>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>pandas (<code>[pandas]</code>): For data analysis and DataFrame conversion</li> <li>cryptography (<code>[crypto]</code>): For secure token encryption and management</li> <li>pydantic (<code>[pydantic]</code>): For data validation (planned for future use)</li> </ul>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>maturin: For building the Rust components</li> <li>pytest: For running tests</li> <li>black: For code formatting</li> <li>isort: For import sorting</li> </ul>"},{"location":"installation/#installation-from-source","title":"Installation from Source","text":"<p>Clone the repository and install in development mode:</p> <pre><code># Clone the repository\ngit clone https://github.com/bmeddeb/GitFleet.git\ncd GitFleet\n\n# Install in development mode with all dependencies\npip install -e \".[all,dev]\"\n\n# Build the Rust components\nmaturin develop\n</code></pre>"},{"location":"installation/#rust-implementation","title":"Rust Implementation","text":"<p>GitFleet automatically detects if its Rust components are available and uses them for better performance. If the Rust components aren't available (for example, on platforms without Rust support), GitFleet falls back to pure Python implementations.</p>"},{"location":"installation/#platform-support","title":"Platform Support","text":"<p>GitFleet is tested on: - Linux (x86_64, aarch64) - macOS (x86_64, Apple Silicon) - Windows (x86_64)</p>"},{"location":"installation/#virtual-environments","title":"Virtual Environments","text":"<p>It's recommended to install GitFleet within a virtual environment:</p> <pre><code># Create a virtual environment\npython -m venv venv\n\n# Activate it (Linux/macOS)\nsource venv/bin/activate\n\n# Activate it (Windows)\nvenv\\Scripts\\activate\n\n# Install GitFleet\npip install \"gitfleet[all]\"\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#rust-build-failures","title":"Rust Build Failures","text":"<p>If you encounter issues building the Rust components:</p> <pre><code># Install required dependencies (Ubuntu/Debian)\napt-get install build-essential libssl-dev pkg-config\n\n# Install with Python-only mode\npip install gitfleet\n# Then force Python implementation in your code:\ngithub = GitHubClient(token=\"your-token\", use_python_impl=True)\n</code></pre>"},{"location":"installation/#missing-optional-dependencies","title":"Missing Optional Dependencies","text":"<p>If you see warnings about missing dependencies:</p> <pre><code># Install the required optional dependency\npip install pandas  # For data analysis\npip install cryptography  # For secure token handling\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>import GitFleet\n\n# Check version\nprint(GitFleet.__version__)  # Should print \"0.2.0\" or newer\n\n# Check if Rust is available (in a script)\nfrom GitFleet import GitHubClient\nclient = GitHubClient(token=\"test\")\nprint(f\"Using Rust: {getattr(client, '_use_rust', False)}\")\n</code></pre>"},{"location":"migration-guide/","title":"Migration Guide","text":"<p>This guide helps users migrate from older versions of GitFleet to the latest version with minimal disruption.</p>"},{"location":"migration-guide/#migrating-from-v01x-to-v02x","title":"Migrating from v0.1.x to v0.2.x","text":"<p>GitFleet v0.2.0 introduces several important changes that improve the structure, type safety, and flexibility of the library.</p>"},{"location":"migration-guide/#key-changes","title":"Key Changes","text":"<ol> <li>Provider APIs: Restructured provider APIs with dataclass-based models</li> <li>Dual Implementation: Option to use either Rust-based or Python implementations </li> <li>Token Management: Built-in TokenManager for handling multiple tokens</li> <li>Error Handling: Improved error hierarchy with provider-specific errors</li> </ol>"},{"location":"migration-guide/#updated-import-paths","title":"Updated Import Paths","text":"<p>The import structure has changed slightly to reflect the new organization:</p> <p>Old (v0.1.x): <pre><code>from GitFleet import RepoManager\nfrom GitFleet.api import GitHubAPI\n</code></pre></p> <p>New (v0.2.x): <pre><code>from GitFleet import RepoManager\nfrom GitFleet import GitHubClient\n</code></pre></p>"},{"location":"migration-guide/#github-client-changes","title":"GitHub Client Changes","text":"<p>The GitHub client has been significantly enhanced with dataclasses:</p> <p>Old (v0.1.x): <pre><code>from GitFleet.api import GitHubAPI\n\ngithub = GitHubAPI(token=\"your-token\")\nrepos = await github.get_repos(\"octocat\")\n\n# Dictionary-based response\nfor repo in repos:\n    print(f\"Name: {repo['name']}\")\n    print(f\"Stars: {repo['stargazers_count']}\")\n</code></pre></p> <p>New (v0.2.x): <pre><code>from GitFleet import GitHubClient\n\ngithub = GitHubClient(token=\"your-token\")\nrepos = await github.fetch_repositories(\"octocat\")\n\n# Dataclass-based response\nfor repo in repos:\n    print(f\"Name: {repo.name}\")\n    print(f\"Stars: {repo.stargazers_count}\")\n</code></pre></p>"},{"location":"migration-guide/#method-naming-changes","title":"Method Naming Changes","text":"<p>Some method names have been updated for clarity and consistency:</p> Old Method (v0.1.x) New Method (v0.2.x) <code>get_repos()</code> <code>fetch_repositories()</code> <code>get_user()</code> <code>fetch_user_info()</code> <code>get_rate_limit()</code> <code>get_rate_limit()</code> (unchanged) <code>get_repo_details()</code> <code>fetch_repository_details()</code> <code>get_contributors()</code> <code>fetch_contributors()</code> <code>get_branches()</code> <code>fetch_branches()</code>"},{"location":"migration-guide/#error-handling-changes","title":"Error Handling Changes","text":"<p>Error classes have been reorganized into a hierarchy:</p> <p>Old (v0.1.x): <pre><code>from GitFleet.api.exceptions import GitHubError, RateLimitError\n\ntry:\n    repos = await github.get_repos(\"octocat\")\nexcept RateLimitError as e:\n    print(f\"Rate limited: {e}\")\nexcept GitHubError as e:\n    print(f\"GitHub error: {e}\")\n</code></pre></p> <p>New (v0.2.x): <pre><code>from GitFleet.providers.base import ProviderError, AuthError, RateLimitError\n\ntry:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept RateLimitError as e:\n    print(f\"Rate limited (resets at {e.reset_time}): {e}\")\nexcept AuthError as e:\n    print(f\"Authentication error: {e}\")\nexcept ProviderError as e:\n    print(f\"Provider error: {e}\")\n</code></pre></p>"},{"location":"migration-guide/#tokenmanager-integration","title":"TokenManager Integration","text":"<p>If you were manually managing tokens before, you can now use the built-in TokenManager:</p> <p>Old (v0.1.x): <pre><code>from GitFleet.api import GitHubAPI\n\n# Manual token rotation\ngithub1 = GitHubAPI(token=\"token1\")\ngithub2 = GitHubAPI(token=\"token2\")\n\ntry:\n    repos = await github1.get_repos(\"octocat\")\nexcept RateLimitError:\n    repos = await github2.get_repos(\"octocat\")\n</code></pre></p> <p>New (v0.2.x): <pre><code>from GitFleet import GitHubClient\nfrom GitFleet.providers import TokenManager, ProviderType\n\n# Automatic token rotation\ntoken_manager = TokenManager()\ntoken_manager.add_token(\"token1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"token2\", ProviderType.GITHUB)\n\ngithub = GitHubClient(token=\"token1\", token_manager=token_manager)\nrepos = await github.fetch_repositories(\"octocat\")  # Automatic token rotation\n</code></pre></p>"},{"location":"migration-guide/#to-pandas-conversion","title":"To Pandas Conversion","text":"<p>The conversion to pandas DataFrames is now more flexible:</p> <p>Old (v0.1.x): <pre><code>import pandas as pd\nrepos = await github.get_repos(\"octocat\")\ndf = pd.DataFrame(repos)\n</code></pre></p> <p>New (v0.2.x): <pre><code># Option 1: Use the utility function\nfrom GitFleet import to_dataframe\nrepos = await github.fetch_repositories(\"octocat\")\ndf = to_dataframe(repos)\n\n# Option 2: Use the client method\nrepos = await github.fetch_repositories(\"octocat\")\ndf = await github.to_pandas(repos)\n</code></pre></p>"},{"location":"migration-guide/#forcing-python-implementation","title":"Forcing Python Implementation","text":"<p>If you encounter issues with the Rust implementation, you can force the Python implementation:</p> <pre><code># Force Python implementation\ngithub = GitHubClient(\n    token=\"your-token\",\n    use_python_impl=True\n)\n</code></pre>"},{"location":"migration-guide/#step-by-step-migration","title":"Step-by-Step Migration","text":"<ol> <li> <p>Update GitFleet: <code>pip install gitfleet&gt;=0.2.0</code></p> </li> <li> <p>Update imports: Change import paths as shown above</p> </li> <li> <p>Update method calls: Rename method calls to match the new names</p> </li> <li> <p>Update response handling: Change dictionary access to attribute access</p> </li> <li> <p>Update error handling: Use the new error hierarchy</p> </li> <li> <p>Consider TokenManager: Use the built-in TokenManager for multiple tokens</p> </li> <li> <p>Test thoroughly: Verify all functionality in a non-production environment</p> </li> </ol>"},{"location":"migration-guide/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"migration-guide/#issue-attributeerror-when-accessing-response-data","title":"Issue: AttributeError when accessing response data","text":"<p>Problem: Accessing response data as a dictionary instead of an object <pre><code>repo['name']  # Error\n</code></pre></p> <p>Solution: Use attribute access <pre><code>repo.name  # Correct\n</code></pre></p>"},{"location":"migration-guide/#issue-modulenotfounderror-for-older-imports","title":"Issue: ModuleNotFoundError for older imports","text":"<p>Problem: Using old import paths <pre><code>from GitFleet.api import GitHubAPI  # Error\n</code></pre></p> <p>Solution: Update import paths <pre><code>from GitFleet import GitHubClient  # Correct\n</code></pre></p>"},{"location":"migration-guide/#issue-tokenmanager-not-working-with-different-providers","title":"Issue: TokenManager not working with different providers","text":"<p>Problem: Not specifying the provider type correctly</p> <p>Solution: Use the ProviderType enum <pre><code>from GitFleet.providers import ProviderType\ntoken_manager.add_token(\"token\", ProviderType.GITHUB)\n</code></pre></p>"},{"location":"migration-guide/#getting-help","title":"Getting Help","text":"<p>If you encounter issues during migration:</p> <ol> <li>Check the documentation</li> <li>Open an issue on the GitHub repository</li> <li>Contact the maintainers at support@example.com</li> </ol>"},{"location":"pydantic-integration/","title":"Pydantic Integration","text":"<p>GitFleet provides comprehensive integration with Pydantic, offering enhanced validation, serialization, and better type safety for all data models.</p>"},{"location":"pydantic-integration/#overview","title":"Overview","text":"<p>Pydantic integration in GitFleet provides the following benefits:</p> <ul> <li>Strong Validation: All API responses are validated against defined schemas</li> <li>Serialization: Easy conversion to JSON, dictionaries, and other formats</li> <li>Type Safety: Improved IDE completions and static type checking</li> <li>Consistent Interface: Same API across Rust and Python components</li> </ul>"},{"location":"pydantic-integration/#data-models","title":"Data Models","text":"<p>All GitFleet data models are built using Pydantic's <code>BaseModel</code> class, including:</p> <ul> <li>Provider models (<code>RepoInfo</code>, <code>UserInfo</code>, etc.)</li> <li>Repository management models (<code>CloneStatus</code>, <code>CloneTask</code>)</li> <li>Token and credential management models</li> </ul>"},{"location":"pydantic-integration/#example-usage","title":"Example Usage","text":""},{"location":"pydantic-integration/#basic-model-usage","title":"Basic Model Usage","text":"<pre><code>from GitFleet import RepoInfo\n\n# Create a model instance with validation\nrepo = RepoInfo(\n    name=\"example-repo\",\n    full_name=\"user/example-repo\",\n    clone_url=\"https://github.com/user/example-repo.git\",\n    provider_type=\"github\"\n)\n\n# Access properties with proper types\nprint(repo.name)  # example-repo\nprint(repo.fork)  # False (default value)\n\n# Convert to dictionary\nrepo_dict = repo.model_dump()\nprint(repo_dict)\n\n# Convert to JSON with custom formatting\nrepo_json = repo.model_dump_json(indent=2)\nprint(repo_json)\n\n# Parse created_at date if available\nif repo.created_at:\n    dt = repo.created_datetime()\n    if dt:\n        print(f\"Created on: {dt.strftime('%Y-%m-%d')}\")\n</code></pre>"},{"location":"pydantic-integration/#working-with-api-responses","title":"Working with API Responses","text":"<p>When using the GitHubClient, all API responses are automatically converted to Pydantic models:</p> <pre><code>from GitFleet import GitHubClient\n\nasync def main():\n    client = GitHubClient(token=\"your-token\")\n\n    # Returns a list of RepoInfo objects\n    repos = await client.fetch_repositories(\"octocat\")\n\n    # Use model methods\n    for repo in repos:\n        print(f\"Repository: {repo.full_name}\")\n        print(f\"Created: {repo.created_datetime()}\")\n\n        # Convert to JSON\n        print(repo.model_dump_json())\n</code></pre>"},{"location":"pydantic-integration/#rust-type-integration","title":"Rust Type Integration","text":"<p>GitFleet provides Pydantic wrappers for the Rust-generated classes:</p> <pre><code>from GitFleet import RepoManager, CloneTask, CloneStatus, CloneStatusType\n\nasync def main():\n    # Create a RepoManager\n    manager = RepoManager(\n        urls=[\"https://github.com/user/repo.git\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Clone repositories\n    await manager.clone_all()\n\n    # Get clone tasks as Pydantic models\n    tasks = await manager.fetch_clone_tasks()\n\n    for url, task in tasks.items():\n        # Access properties with proper type hints\n        print(f\"Repository: {url}\")\n        print(f\"Status: {task.status.status_type}\")\n\n        # Use Pydantic features\n        print(task.model_dump_json(indent=2))\n\n        # Enums for type safety\n        if task.status.status_type == CloneStatusType.COMPLETED:\n            print(f\"Cloned to: {task.temp_dir}\")\n</code></pre>"},{"location":"pydantic-integration/#installation","title":"Installation","text":"<p>To use Pydantic features, install GitFleet with the Pydantic extra:</p> <pre><code>pip install \"gitfleet[pydantic]\"\n</code></pre> <p>Or install with multiple extras:</p> <pre><code>pip install \"gitfleet[pydantic,pandas]\"\n</code></pre>"},{"location":"pydantic-integration/#conversion-utilities","title":"Conversion Utilities","text":"<p>GitFleet provides utility functions for working with Pydantic models:</p> <ul> <li><code>to_dict(obj)</code>: Convert any object to a dictionary</li> <li><code>to_json(obj, indent=None)</code>: Convert any object to a JSON string</li> <li><code>to_dataframe(data)</code>: Convert models to a pandas DataFrame</li> <li><code>flatten_dataframe(df)</code>: Flatten nested structures in a DataFrame</li> </ul>"},{"location":"pydantic-integration/#type-stubs","title":"Type Stubs","text":"<p>GitFleet includes comprehensive type stubs (<code>.pyi</code> files) for all Pydantic models, ensuring proper IDE completions and static type checking support.</p>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you get started with GitFleet quickly. We'll cover installation, basic setup, and common operations.</p>"},{"location":"quick-start/#installation","title":"Installation","text":"<p>Install GitFleet using pip:</p> <pre><code>pip install gitfleet\n</code></pre> <p>For development installations:</p> <pre><code>git clone https://github.com/bmeddeb/GitFleet.git\ncd GitFleet\npip install -e .\n</code></pre>"},{"location":"quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"quick-start/#initializing-the-repository-manager","title":"Initializing the Repository Manager","text":"<pre><code>import asyncio\nfrom GitFleet import RepoManager\n\n# Replace with your credentials\ngithub_username = \"your-username\"\ngithub_token = \"your-github-token\"\n\n# List of repositories to work with\nrepos = [\n    \"https://github.com/user/repo1\",\n    \"https://github.com/user/repo2\"\n]\n\n# Initialize the repository manager\nrepo_manager = RepoManager(\n    urls=repos,\n    github_username=github_username,\n    github_token=github_token\n)\n</code></pre>"},{"location":"quick-start/#cloning-repositories","title":"Cloning Repositories","text":"<pre><code>async def main():\n    # Clone all repositories asynchronously\n    clone_future = repo_manager.clone_all()\n\n    # Wait for cloning to complete\n    await clone_future\n\n    # Get the status of all clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find successfully cloned repositories\n    for url, task in clone_tasks.items():\n        if task.status.status_type == \"completed\":\n            print(f\"Successfully cloned {url} to {task.temp_dir}\")\n        elif task.status.status_type == \"failed\":\n            print(f\"Failed to clone {url}: {task.status.error}\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"quick-start/#analyzing-repository-data","title":"Analyzing Repository Data","text":""},{"location":"quick-start/#blame-analysis","title":"Blame Analysis","text":"<pre><code>async def analyze_blame(repo_path, file_paths):\n    # Get blame information for specified files\n    blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n    # Process the results\n    for file_path, blame_info in blame_results.items():\n        if isinstance(blame_info, list):  # Success case\n            print(f\"Blame for {file_path}:\")\n            # Count lines by author\n            authors = {}\n            for line in blame_info:\n                author = line[\"author_name\"]\n                authors[author] = authors.get(author, 0) + 1\n\n            # Show top contributors\n            for author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True):\n                print(f\"  {author}: {count} lines\")\n        else:  # Error case\n            print(f\"Error analyzing {file_path}: {blame_info}\")\n</code></pre>"},{"location":"quick-start/#commit-analysis","title":"Commit Analysis","text":"<pre><code>async def analyze_commits(repo_path):\n    # Extract commit history\n    commits = await repo_manager.extract_commits(repo_path)\n\n    if isinstance(commits, list):  # Success case\n        print(f\"Found {len(commits)} commits\")\n\n        # Show recent commits\n        for commit in commits[:5]:\n            print(f\"Commit: {commit['sha'][:7]}\")\n            print(f\"Author: {commit['author_name']}\")\n            print(f\"Message: {commit['message'].split('\\n')[0]}\")\n            print(f\"Changes: +{commit['additions']} -{commit['deletions']}\")\n    else:  # Error case\n        print(f\"Error analyzing commits: {commits}\")\n</code></pre>"},{"location":"quick-start/#cleaning-up","title":"Cleaning Up","text":"<pre><code>async def cleanup():\n    # Clean up all temporary directories\n    cleanup_results = await repo_manager.cleanup()\n\n    # Check cleanup results\n    for url, result in cleanup_results.items():\n        if result is True:\n            print(f\"Successfully cleaned up {url}\")\n        else:\n            print(f\"Failed to clean up {url}: {result}\")\n</code></pre>"},{"location":"quick-start/#complete-example","title":"Complete Example","text":"<p>Here's a complete example putting everything together:</p> <pre><code>import asyncio\nimport os\nfrom GitFleet import RepoManager\n\nasync def main():\n    # Initialize repository manager with credentials from environment\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/bmeddeb/gradelib\"],\n        github_username=os.environ.get(\"GITHUB_USERNAME\"),\n        github_token=os.environ.get(\"GITHUB_TOKEN\")\n    )\n\n    # Clone repositories\n    await repo_manager.clone_all()\n\n    # Get clone statuses\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a successfully cloned repository\n    repo_path = None\n    for url, task in clone_tasks.items():\n        if task.status.status_type == \"completed\":\n            repo_path = task.temp_dir\n            print(f\"Analyzing repository: {url}\")\n            break\n\n    if repo_path:\n        # Find Python files in the repository\n        file_paths = []\n        for root, _, files in os.walk(repo_path):\n            for file in files:\n                if file.endswith(\".py\"):\n                    rel_path = os.path.join(root, file).replace(repo_path + os.sep, \"\")\n                    file_paths.append(rel_path)\n                    if len(file_paths) &gt;= 3:  # Limit to 3 files\n                        break\n            if len(file_paths) &gt;= 3:\n                break\n\n        # Analyze blame\n        if file_paths:\n            blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n            for file_path, blame_info in blame_results.items():\n                if isinstance(blame_info, list):\n                    authors = {}\n                    for line in blame_info:\n                        author = line[\"author_name\"]\n                        authors[author] = authors.get(author, 0) + 1\n\n                    print(f\"\\nBlame summary for {file_path}:\")\n                    for author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True):\n                        print(f\"  {author}: {count} lines\")\n\n        # Analyze commits\n        commits = await repo_manager.extract_commits(repo_path)\n        if isinstance(commits, list):\n            print(f\"\\nFound {len(commits)} commits\")\n            print(\"Recent commits:\")\n            for commit in commits[:3]:\n                print(f\"  {commit['sha'][:7]} - {commit['message'].split('\\\\n')[0]}\")\n\n    # Clean up\n    await repo_manager.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Repository Manager: More details on repository management</li> <li>Clone Operations: Advanced clone monitoring</li> <li>Provider APIs: Working with Git hosting providers</li> <li>Examples: More complete examples</li> </ul>"},{"location":"token-management/","title":"Token Management","text":"<p>GitFleet includes a built-in token management system that helps you handle API rate limits and authentication across multiple tokens. This is especially useful for high-volume applications that need to maximize their API usage.</p>"},{"location":"token-management/#why-token-management","title":"Why Token Management?","text":"<p>Git hosting providers like GitHub, GitLab, and BitBucket implement rate limiting on their APIs to ensure fair usage. When you exceed these limits, your requests will be rejected until the rate limit resets.</p> <p>Using multiple tokens allows you to:</p> <ol> <li>Increase the total number of requests you can make</li> <li>Continue operations when one token hits its rate limit</li> <li>Distribute API load across multiple accounts</li> <li>Maintain availability even when some tokens become invalid</li> </ol>"},{"location":"token-management/#built-in-tokenmanager","title":"Built-in TokenManager","text":"<p>GitFleet provides a <code>TokenManager</code> class that automatically handles token rotation, rate limit tracking, and fallback logic:</p> <pre><code>import asyncio\nfrom GitFleet import GitHubClient\nfrom GitFleet.providers import TokenManager, ProviderType\n\n# Create a token manager\ntoken_manager = TokenManager()\n\n# Add tokens for GitHub\ntoken_manager.add_token(\"your-token-1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"your-token-2\", ProviderType.GITHUB)\ntoken_manager.add_token(\"your-token-3\", ProviderType.GITHUB)\n\n# Create a client with the token manager\ngithub = GitHubClient(\n    token=\"your-token-1\",  # Default token\n    token_manager=token_manager  # Token manager for rotation\n)\n\n# Now use the client as normal - it will automatically rotate tokens as needed\nasync def main():\n    # This will automatically use the next available token if rate limits are hit\n    repos = await github.fetch_repositories(\"octocat\")\n    user = await github.fetch_user_info()\n\n    # Check how many tokens are still available\n    available = token_manager.count_available_tokens(ProviderType.GITHUB)\n    print(f\"{available} GitHub tokens available\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"token-management/#token-states","title":"Token States","text":"<p>Each token in the manager has one of the following states:</p> <ul> <li>Available: The token is valid and has API calls remaining</li> <li>Rate Limited: The token has exceeded its rate limit and will become available again after the reset time</li> <li>Invalid: The token is invalid (e.g., revoked, expired)</li> </ul> <p>The token manager automatically: - Tracks rate limits for all tokens - Skips rate-limited tokens until they reset - Removes invalid tokens from rotation - Uses the least recently used available token</p>"},{"location":"token-management/#using-multiple-providers","title":"Using Multiple Providers","text":"<p>You can register tokens for different providers:</p> <pre><code>from GitFleet.providers import TokenManager, ProviderType\n\n# Create a token manager\ntoken_manager = TokenManager()\n\n# Add tokens for different providers\ntoken_manager.add_token(\"github-token-1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"github-token-2\", ProviderType.GITHUB)\ntoken_manager.add_token(\"gitlab-token-1\", ProviderType.GITLAB)  # (Future)\ntoken_manager.add_token(\"gitlab-token-2\", ProviderType.GITLAB)  # (Future)\n\n# Create provider clients with the same token manager\ngithub = GitHubClient(token=\"github-token-1\", token_manager=token_manager)\n# gitlab = GitLabClient(token=\"gitlab-token-1\", token_manager=token_manager)  # (Future)\n</code></pre>"},{"location":"token-management/#manual-token-management","title":"Manual Token Management","text":"<p>For simple cases, you can also manually handle tokens:</p> <pre><code>import asyncio\nfrom GitFleet import GitHubClient\nfrom GitFleet.providers.base import RateLimitError\n\n# Initialize clients with different tokens\ngithub1 = GitHubClient(token=\"token1\")\ngithub2 = GitHubClient(token=\"token2\")\n\nasync def fetch_with_fallback(owner):\n    try:\n        # Try with the first token\n        repos = await github1.fetch_repositories(owner)\n        return repos\n    except RateLimitError:\n        # Fallback to the second token\n        repos = await github2.fetch_repositories(owner)\n        return repos\n</code></pre>"},{"location":"token-management/#rate-limit-awareness","title":"Rate Limit Awareness","text":"<p>With the built-in <code>TokenManager</code>, rate limits are tracked automatically. However, you can also manually check rate limits:</p> <pre><code># Check rate limits for a specific client\nrate_limit = await github.get_rate_limit()\nprint(f\"Remaining: {rate_limit.remaining}/{rate_limit.limit}\")\nprint(f\"Reset time: {rate_limit.reset_time}\")\n\n# Check all tokens in a token manager\nfrom GitFleet.providers import TokenManager, ProviderType\n\ntoken_manager = TokenManager()\ntoken_manager.add_token(\"token1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"token2\", ProviderType.GITHUB)\n\n# Get all GitHub tokens\ngithub_tokens = token_manager.get_all_tokens(ProviderType.GITHUB)\nfor i, token_info in enumerate(github_tokens):\n    if token_info.rate_limit:\n        print(f\"Token {i+1}: {token_info.rate_limit.remaining}/{token_info.rate_limit.limit}\")\n        print(f\"Status: {token_info.status}\")\n    else:\n        print(f\"Token {i+1}: Rate limit not yet fetched\")\n</code></pre>"},{"location":"token-management/#token-information-class","title":"Token Information Class","text":"<p>The <code>TokenInfo</code> class stores information about each token:</p> <pre><code>@dataclass\nclass TokenInfo:\n    token: str                  # The actual token string\n    provider_type: ProviderType # Which provider this token is for\n    status: TokenStatus         # Current status (Available/RateLimited/Invalid)\n    rate_limit: RateLimitInfo   # Current rate limit information\n    username: str               # Optional username associated with token\n    last_used: int              # Timestamp when token was last used\n</code></pre>"},{"location":"token-management/#token-status-enumeration","title":"Token Status Enumeration","text":"<p>The <code>TokenStatus</code> enumeration represents the current state of a token:</p> <pre><code>from GitFleet.providers import TokenStatus\n\n# Check token status\nif token_info.status == TokenStatus.AVAILABLE:\n    print(\"Token is available\")\nelif token_info.status == TokenStatus.RATE_LIMITED:\n    print(f\"Token is rate limited until {token_info.rate_limit.reset_time}\")\nelif token_info.status == TokenStatus.INVALID:\n    print(\"Token is invalid or revoked\")\n</code></pre>"},{"location":"token-management/#multiple-tokens-example","title":"Multiple Tokens Example","text":"<p>Here's a complete example using the token manager with multiple tokens from environment variables:</p> <pre><code>import os\nimport asyncio\nfrom GitFleet import GitHubClient\nfrom GitFleet.providers import TokenManager, ProviderType\n\nasync def main():\n    # Get tokens from environment (comma-separated)\n    tokens = os.environ.get(\"GITHUB_TOKENS\", \"\").split(\",\")\n    if not tokens or not tokens[0]:\n        print(\"No tokens found. Set GITHUB_TOKENS environment variable.\")\n        return\n\n    # Create token manager and add tokens\n    token_manager = TokenManager()\n    for token in tokens:\n        token_manager.add_token(token, ProviderType.GITHUB)\n\n    # Create client with token manager\n    github = GitHubClient(\n        token=tokens[0],  # First token as default\n        token_manager=token_manager\n    )\n\n    # Fetch repositories for multiple users\n    users = [\"octocat\", \"torvalds\", \"gvanrossum\", \"kennethreitz\"]\n\n    for user in users:\n        try:\n            repos = await github.fetch_repositories(user)\n            print(f\"Found {len(repos)} repositories for {user}\")\n\n            # The token manager automatically rotated tokens if needed\n        except Exception as e:\n            print(f\"Error fetching repos for {user}: {e}\")\n\n    # Check token statuses after operations\n    print(\"\\nToken statuses:\")\n    for i, token_info in enumerate(token_manager.get_all_tokens(ProviderType.GITHUB)):\n        status = \"Available\"\n        if token_info.status == TokenStatus.RATE_LIMITED:\n            status = f\"Rate limited (resets at {token_info.rate_limit.reset_time})\"\n        elif token_info.status == TokenStatus.INVALID:\n            status = \"Invalid\"\n\n        print(f\"Token {i+1}: {status}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"token-management/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Store tokens securely: Never hard-code tokens in your source code. Use environment variables or secure secret management.</p> </li> <li> <p>Use the built-in TokenManager: Let GitFleet handle token rotation and rate limiting automatically.</p> </li> <li> <p>Handle rate limit errors: Always catch <code>RateLimitError</code> exceptions and implement appropriate fallback logic.</p> </li> <li> <p>Respect API limits: Even with multiple tokens, be respectful of API limits and avoid making unnecessary requests.</p> </li> <li> <p>Implement exponential backoff: When all tokens are rate-limited, implement exponential backoff before retrying.</p> </li> </ol> <pre><code>import asyncio\nimport time\nimport random\nfrom GitFleet.providers.base import RateLimitError\n\nasync def fetch_with_backoff(client, owner, max_retries=5):\n    for attempt in range(max_retries):\n        try:\n            return await client.fetch_repositories(owner)\n        except RateLimitError as e:\n            if attempt == max_retries - 1:\n                raise  # Give up after max_retries\n\n            # Calculate wait time with exponential backoff and jitter\n            wait_time = min(2 ** attempt + random.random(), 60)\n            print(f\"Rate limited. Waiting {wait_time:.2f} seconds before retry...\")\n            await asyncio.sleep(wait_time)\n</code></pre>"},{"location":"token-management/#secure-token-storage","title":"Secure Token Storage","text":"<p>For production applications, consider using environment variables or a secure credential store:</p> <pre><code>import os\nfrom GitFleet import GitHubClient\nfrom GitFleet.providers import TokenManager, ProviderType\n\n# Get tokens from environment variables\ntoken = os.environ.get(\"GITHUB_TOKEN\")\nif not token:\n    raise ValueError(\"GITHUB_TOKEN environment variable not set\")\n\n# Create the client\ngithub = GitHubClient(token=token)\n</code></pre> <p>For more secure storage in Python applications, consider using packages like: - <code>python-dotenv</code> for loading from .env files - <code>keyring</code> for system keychain integration - <code>vault</code> for HashiCorp Vault integration</p>"},{"location":"api/","title":"GitFleet Core API Reference","text":"<p>The GitFleet Core API provides a set of high-performance operations for Git repositories, implemented in Rust with Python bindings. This page serves as a central reference for the main components of the Core API.</p>"},{"location":"api/#main-components","title":"Main Components","text":""},{"location":"api/#repository-management","title":"Repository Management","text":"<p>The RepoManager class is the central interface for working with Git repositories. It provides methods for:</p> <ul> <li>Cloning repositories</li> <li>Monitoring clone status</li> <li>Extracting blame information</li> <li>Analyzing commit history</li> <li>Managing temporary repositories</li> </ul>"},{"location":"api/#clone-operations","title":"Clone Operations","text":"<p>GitFleet provides a robust system for asynchronously cloning repositories and monitoring their status:</p> <ul> <li>CloneStatus: Represents the status of a repository cloning operation</li> <li>CloneTask: Represents a repository cloning task with metadata</li> <li>Clone Monitoring: Advanced techniques for monitoring clone operations</li> </ul>"},{"location":"api/#blame-and-commit-analysis","title":"Blame and Commit Analysis","text":"<p>GitFleet excels at high-performance blame and commit analysis:</p> <ul> <li>Blame &amp; Commit Analysis: Extract detailed blame information and commit history</li> </ul>"},{"location":"api/#performance-features","title":"Performance Features","text":"<p>The Core API is designed for high performance:</p> <ul> <li>Rust Implementation: Core operations implemented in Rust for maximum speed</li> <li>Asynchronous Operations: All repository operations are non-blocking using asyncio</li> <li>Parallel Processing: Multiple repositories can be processed concurrently</li> <li>Efficient Memory Usage: Optimized data structures for large repositories</li> </ul>"},{"location":"api/#common-usage-patterns","title":"Common Usage Patterns","text":"<pre><code>import asyncio\nfrom GitFleet import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo\"],\n        github_username=\"your-username\",\n        github_token=\"your-token\"\n    )\n\n    # Clone repositories\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Get a repository path from a successful clone\n    repo_path = next(\n        (task.temp_dir for task in clone_tasks.values() \n         if task.status.status_type == \"completed\"),\n        None\n    )\n\n    if repo_path:\n        # Analyze blame for files\n        file_paths = [\"README.md\", \"src/main.py\"]\n        blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n        # Extract commit history\n        commits = await repo_manager.extract_commits(repo_path)\n\n    # Clean up temporary directories\n    await repo_manager.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>GitFleet provides comprehensive error handling through:</p> <ul> <li>Clear error messages</li> <li>Exception hierarchies</li> <li>Status objects with detailed error information</li> </ul> <p>See the Error Handling guide for more details.</p>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>Repository Manager: Detailed documentation for the main RepoManager class</li> <li>CloneStatus and CloneTask: Working with clone operations</li> <li>Examples: Practical examples of using the Core API</li> </ul>"},{"location":"api/blame-commit/","title":"Blame and Commit Analysis","text":"<p>GitFleet provides powerful tools for analyzing repository blame information and commit history. This page explains how to use these features and interpret the results.</p>"},{"location":"api/blame-commit/#blame-analysis","title":"Blame Analysis","text":"<p>Blame analysis identifies the author and commit information for each line of code in a file. GitFleet's blame analysis is implemented in Rust for maximum performance, making it significantly faster than pure Python implementations.</p>"},{"location":"api/blame-commit/#using-the-bulk_blame-method","title":"Using the <code>bulk_blame</code> Method","text":"<p>The <code>bulk_blame</code> method allows you to analyze blame information for multiple files at once:</p> <pre><code>import asyncio\nfrom GitFleet import RepoManager\n\nasync def analyze_blame():\n    # Initialize repository manager\n    repo_manager = RepoManager(urls=[\"https://github.com/user/repo\"])\n\n    # Clone the repository\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a successfully cloned repository\n    repo_path = None\n    for task in clone_tasks.values():\n        if task.status.status_type == \"completed\":\n            repo_path = task.temp_dir\n            break\n\n    if repo_path:\n        # Specify files to analyze\n        file_paths = [\n            \"README.md\",\n            \"src/main.py\",\n            \"tests/test_main.py\"\n        ]\n\n        # Get blame information\n        blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n        # Process the results\n        for file_path, blame_info in blame_results.items():\n            if isinstance(blame_info, list):  # Success case\n                print(f\"Blame for {file_path}:\")\n\n                # Create a summary by author\n                authors = {}\n                for line in blame_info:\n                    author = line[\"author_name\"]\n                    authors[author] = authors.get(author, 0) + 1\n\n                # Print the summary\n                for author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True):\n                    print(f\"  {author}: {count} lines\")\n            else:  # Error case\n                print(f\"Error analyzing {file_path}: {blame_info}\")\n</code></pre>"},{"location":"api/blame-commit/#blame-result-structure","title":"Blame Result Structure","text":"<p>The <code>bulk_blame</code> method returns a dictionary where: - Keys are file paths - Values are either:   - Lists of line blame information (success case)   - Error messages (error case)</p> <p>For each line in a file, the blame information includes:</p> Field Type Description <code>commit_id</code> string SHA-1 hash of the commit <code>author_name</code> string Name of the author <code>author_email</code> string Email of the author <code>orig_line_no</code> int Original line number in the commit <code>final_line_no</code> int Current line number in the file <code>line_content</code> string Content of the line"},{"location":"api/blame-commit/#advanced-blame-analysis","title":"Advanced Blame Analysis","text":"<p>You can perform more advanced blame analysis by processing the detailed information:</p> <pre><code># Group by commit\ncommits = {}\nfor line in blame_info:\n    commit_id = line[\"commit_id\"]\n    if commit_id not in commits:\n        commits[commit_id] = 0\n    commits[commit_id] += 1\n\n# Find the most significant commits\nsignificant_commits = sorted(commits.items(), key=lambda x: x[1], reverse=True)[:5]\nprint(\"Most significant commits:\")\nfor commit_id, count in significant_commits:\n    print(f\"  {commit_id[:7]}: {count} lines\")\n</code></pre>"},{"location":"api/blame-commit/#commit-analysis","title":"Commit Analysis","text":"<p>Commit analysis extracts detailed information about the commit history of a repository. This includes commit metadata, authorship information, and change statistics.</p>"},{"location":"api/blame-commit/#using-the-extract_commits-method","title":"Using the <code>extract_commits</code> Method","text":"<pre><code>import asyncio\nfrom GitFleet import RepoManager\nfrom datetime import datetime\n\nasync def analyze_commits():\n    # Initialize repository manager\n    repo_manager = RepoManager(urls=[\"https://github.com/user/repo\"])\n\n    # Clone the repository\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a successfully cloned repository\n    repo_path = None\n    for task in clone_tasks.values():\n        if task.status.status_type == \"completed\":\n            repo_path = task.temp_dir\n            break\n\n    if repo_path:\n        # Extract commit history\n        commits = await repo_manager.extract_commits(repo_path)\n\n        if isinstance(commits, list):  # Success case\n            print(f\"Found {len(commits)} commits\")\n\n            # Show recent commits\n            print(\"\\nRecent commits:\")\n            for commit in commits[:5]:\n                # Convert timestamp to datetime\n                timestamp = commit[\"author_timestamp\"]\n                date = datetime.fromtimestamp(timestamp)\n\n                print(f\"Commit: {commit['sha'][:7]}\")\n                print(f\"Author: {commit['author_name']} &lt;{commit['author_email']}&gt;\")\n                print(f\"Date: {date.strftime('%Y-%m-%d %H:%M:%S')}\")\n                print(f\"Message: {commit['message'].split('\\\\n')[0]}\")\n                print(f\"Changes: +{commit['additions']} -{commit['deletions']}\")\n                print()\n        else:  # Error case\n            print(f\"Error extracting commits: {commits}\")\n</code></pre>"},{"location":"api/blame-commit/#commit-result-structure","title":"Commit Result Structure","text":"<p>The <code>extract_commits</code> method returns either: - A list of commit information objects (success case) - An error message (error case)</p> <p>Each commit information object includes:</p> Field Type Description <code>sha</code> string Full SHA-1 hash of the commit <code>repo_name</code> string Name of the repository <code>message</code> string Full commit message <code>author_name</code> string Name of the author <code>author_email</code> string Email of the author <code>author_timestamp</code> int Author timestamp (Unix epoch) <code>author_offset</code> int Author timezone offset in minutes <code>committer_name</code> string Name of the committer <code>committer_email</code> string Email of the committer <code>committer_timestamp</code> int Committer timestamp (Unix epoch) <code>committer_offset</code> int Committer timezone offset in minutes <code>additions</code> int Number of lines added <code>deletions</code> int Number of lines deleted <code>is_merge</code> bool Whether this is a merge commit"},{"location":"api/blame-commit/#advanced-commit-analysis","title":"Advanced Commit Analysis","text":"<p>You can perform more advanced commit analysis to extract insights:</p> <pre><code># Analyze commit activity over time\nfrom collections import defaultdict\nimport time\n\n# Group commits by month\nmonths = defaultdict(int)\nfor commit in commits:\n    # Get the month from the timestamp\n    date = datetime.fromtimestamp(commit[\"author_timestamp\"])\n    month_key = f\"{date.year}-{date.month:02d}\"\n    months[month_key] += 1\n\n# Print activity by month\nprint(\"Commit activity by month:\")\nfor month, count in sorted(months.items()):\n    print(f\"  {month}: {count} commits\")\n\n# Analyze authors\nauthors = defaultdict(int)\nfor commit in commits:\n    author = commit[\"author_name\"]\n    authors[author] += 1\n\n# Print top contributors\nprint(\"\\nTop contributors:\")\nfor author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True)[:5]:\n    print(f\"  {author}: {count} commits\")\n\n# Analyze code changes\ntotal_additions = sum(commit[\"additions\"] for commit in commits)\ntotal_deletions = sum(commit[\"deletions\"] for commit in commits)\nprint(f\"\\nTotal changes: +{total_additions} -{total_deletions}\")\n</code></pre>"},{"location":"api/blame-commit/#integrating-with-pandas","title":"Integrating with Pandas","text":"<p>GitFleet's results can be easily converted to pandas DataFrames for advanced analysis:</p> <pre><code>import pandas as pd\n\n# Convert blame results to DataFrame\ndef blame_to_dataframe(blame_info):\n    return pd.DataFrame(blame_info)\n\n# Convert commit results to DataFrame\ndef commits_to_dataframe(commits):\n    df = pd.DataFrame(commits)\n\n    # Convert timestamps to datetime\n    df[\"author_date\"] = pd.to_datetime(df[\"author_timestamp\"], unit=\"s\")\n    df[\"committer_date\"] = pd.to_datetime(df[\"committer_timestamp\"], unit=\"s\")\n\n    return df\n\n# Usage\nblame_df = blame_to_dataframe(blame_info)\ncommits_df = commits_to_dataframe(commits)\n\n# Example analyses\n# Author contribution by month\nauthor_monthly = commits_df.groupby([\n    commits_df[\"author_date\"].dt.year, \n    commits_df[\"author_date\"].dt.month, \n    \"author_name\"\n])[\"sha\"].count()\n\n# Lines added/removed ratio\ncommits_df[\"change_ratio\"] = commits_df[\"additions\"] / (commits_df[\"deletions\"] + 1)\n</code></pre>"},{"location":"api/blame-commit/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Blame Analysis: For large repositories or files, blame analysis can be resource-intensive. Consider limiting the number of files analyzed at once.</li> <li>Commit Extraction: The <code>extract_commits</code> method retrieves all commits by default. For repositories with very large histories, this can be slow and memory-intensive.</li> <li>Parallelism: The Rust implementation automatically parallelizes operations where possible, but system resources still impact performance.</li> </ul>"},{"location":"api/blame-commit/#related-documentation","title":"Related Documentation","text":"<ul> <li>Repository Manager: Main interface for repository operations</li> <li>Basic Usage Example: Complete example of blame and commit analysis</li> <li>Performance Tips: Tips for maximizing performance</li> </ul>"},{"location":"api/clone-monitoring/","title":"Clone Monitoring","text":"<p>GitFleet provides a powerful system for asynchronously cloning Git repositories and monitoring the clone progress. This page explains how to monitor clone operations effectively.</p>"},{"location":"api/clone-monitoring/#overview","title":"Overview","text":"<p>When cloning repositories with GitFleet, you can:</p> <ol> <li>Monitor the progress of clone operations in real-time</li> <li>Get detailed status information for each clone task</li> <li>Handle clone failures gracefully</li> <li>Visualize clone progress in various ways</li> </ol>"},{"location":"api/clone-monitoring/#clone-status-types","title":"Clone Status Types","text":"<p>Each clone task can have one of the following status types:</p> Status Type Description <code>queued</code> The clone task is queued but not yet started <code>cloning</code> The clone operation is in progress <code>completed</code> The clone operation completed successfully <code>failed</code> The clone operation failed <p>For <code>cloning</code> status, a progress percentage is also available. For <code>failed</code> status, an error message is provided.</p>"},{"location":"api/clone-monitoring/#basic-clone-monitoring","title":"Basic Clone Monitoring","text":"<p>The simplest way to monitor clone operations is to check the status after cloning:</p> <pre><code>import asyncio\nfrom GitFleet import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Start cloning all repositories\n    await repo_manager.clone_all()\n\n    # Get the status of all clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Check each task's status\n    for url, task in clone_tasks.items():\n        status_type = task.status.status_type\n\n        if status_type == \"completed\":\n            print(f\"\u2705 {url} - Cloned successfully to {task.temp_dir}\")\n        elif status_type == \"failed\":\n            print(f\"\u274c {url} - Failed: {task.status.error}\")\n        else:\n            print(f\"\u23f3 {url} - Status: {status_type}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/clone-monitoring/#real-time-progress-monitoring","title":"Real-Time Progress Monitoring","text":"<p>For a better user experience, you can monitor clone progress in real-time:</p> <pre><code>import asyncio\nimport os\nfrom GitFleet import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo1\", \"https://github.com/user/repo2\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Start cloning all repositories (returns a future)\n    clone_future = repo_manager.clone_all()\n\n    # Monitor progress until all clones complete\n    try:\n        while not clone_future.done():\n            # Get current status of all clone tasks\n            clone_tasks = await repo_manager.fetch_clone_tasks()\n\n            # Clear terminal (for a cleaner display)\n            os.system('cls' if os.name == 'nt' else 'clear')\n\n            print(\"Repository Clone Status\\n\")\n\n            # Flag to check if all tasks are complete\n            all_done = True\n\n            for url, task in clone_tasks.items():\n                status = task.status.status_type\n                progress = task.status.progress\n\n                # Pretty status indicators\n                status_icon = {\n                    \"queued\": \"\u231b\",\n                    \"cloning\": \"\ud83d\udd04\",\n                    \"completed\": \"\u2705\",\n                    \"failed\": \"\u274c\",\n                }.get(status, \"\u2753\")\n\n                print(f\"{status_icon} {url}\")\n\n                # Show progress bar for cloning status\n                if status == \"cloning\" and progress is not None:\n                    bar_length = 30\n                    filled_length = int(bar_length * progress / 100)\n                    bar = \"\u2588\" * filled_length + \"\u2591\" * (bar_length - filled_length)\n                    print(f\"  Progress: [{bar}] {progress}%\")\n\n                # Show error if failed\n                if status == \"failed\" and task.status.error:\n                    print(f\"  Error: {task.status.error}\")\n\n                # Show clone directory if available\n                if task.temp_dir:\n                    print(f\"  Directory: {task.temp_dir}\")\n\n                print()\n\n                # Check if we need to continue monitoring\n                if status not in [\"completed\", \"failed\"]:\n                    all_done = False\n\n            # Exit the loop if all done\n            if all_done:\n                break\n\n            # Wait before refreshing\n            await asyncio.sleep(1)\n\n        # Make sure the clone_all task completes\n        await clone_future\n\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring interrupted. Clone operations may continue in the background.\")\n\n    print(\"All clone operations completed or failed.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/clone-monitoring/#handling-timeouts-and-cancellation","title":"Handling Timeouts and Cancellation","text":"<p>For long-running clone operations, you may want to implement timeouts:</p> <pre><code>import asyncio\nfrom GitFleet import RepoManager\n\nasync def clone_with_timeout(repo_manager, timeout=300):  # 5 minutes timeout\n    # Start cloning\n    clone_future = repo_manager.clone_all()\n\n    try:\n        # Wait for cloning to complete with timeout\n        await asyncio.wait_for(clone_future, timeout=timeout)\n        print(\"All clones completed successfully\")\n    except asyncio.TimeoutError:\n        print(f\"Clone operation timed out after {timeout} seconds\")\n\n        # Check status of timed-out clones\n        clone_tasks = await repo_manager.fetch_clone_tasks()\n\n        for url, task in clone_tasks.items():\n            if task.status.status_type != \"completed\":\n                print(f\"Incomplete: {url} - Status: {task.status.status_type}\")\n\n    # Get final status\n    return await repo_manager.fetch_clone_tasks()\n</code></pre>"},{"location":"api/clone-monitoring/#visualizing-clone-progress-in-a-web-interface","title":"Visualizing Clone Progress in a Web Interface","text":"<p>GitFleet can be integrated with web interfaces to provide a better visualization of clone progress. Here's a simple example using Flask:</p> <pre><code>from flask import Flask, jsonify\nimport asyncio\nfrom GitFleet import RepoManager\n\napp = Flask(__name__)\n\n# Shared repo manager for the app\nrepo_manager = None\nclone_tasks = {}\n\n@app.route('/start_clone', methods=['POST'])\ndef start_clone():\n    global repo_manager\n\n    # Initialize repo manager with URLs from request\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo1\", \"https://github.com/user/repo2\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Start clone in background task\n    asyncio.create_task(clone_and_monitor())\n\n    return jsonify({\"status\": \"started\"})\n\n@app.route('/status', methods=['GET'])\ndef get_status():\n    # Return current status\n    return jsonify(clone_tasks)\n\nasync def clone_and_monitor():\n    global clone_tasks\n\n    # Start cloning\n    clone_future = repo_manager.clone_all()\n\n    # Monitor until complete\n    while not clone_future.done():\n        # Update status\n        tasks = await repo_manager.fetch_clone_tasks()\n\n        # Convert to serializable format\n        clone_tasks = {}\n        for url, task in tasks.items():\n            clone_tasks[url] = {\n                \"status\": task.status.status_type,\n                \"progress\": task.status.progress,\n                \"error\": task.status.error,\n                \"directory\": task.temp_dir\n            }\n\n        # Wait before checking again\n        await asyncio.sleep(1)\n\n    # One final update\n    tasks = await repo_manager.fetch_clone_tasks()\n\n    # Convert to serializable format\n    clone_tasks = {}\n    for url, task in tasks.items():\n        clone_tasks[url] = {\n            \"status\": task.status.status_type,\n            \"progress\": task.status.progress,\n            \"error\": task.status.error,\n            \"directory\": task.temp_dir\n        }\n\n# Sample HTML/JS client:\n\"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Clone Monitor&lt;/title&gt;\n    &lt;script&gt;\n        function updateStatus() {\n            fetch('/status')\n                .then(response =&gt; response.json())\n                .then(data =&gt; {\n                    const statusDiv = document.getElementById('status');\n                    statusDiv.innerHTML = '';\n\n                    for (const [url, task] of Object.entries(data)) {\n                        const taskDiv = document.createElement('div');\n                        taskDiv.className = 'task';\n\n                        // Add task info\n                        taskDiv.innerHTML = `&lt;h3&gt;${url}&lt;/h3&gt;\n                                            &lt;p&gt;Status: ${task.status}&lt;/p&gt;`;\n\n                        // Add progress bar if cloning\n                        if (task.status === 'cloning' &amp;&amp; task.progress !== null) {\n                            taskDiv.innerHTML += `\n                                &lt;div class=\"progress\"&gt;\n                                    &lt;div class=\"progress-bar\" style=\"width: ${task.progress}%\"&gt;\n                                        ${task.progress}%\n                                    &lt;/div&gt;\n                                &lt;/div&gt;`;\n                        }\n\n                        // Add error if failed\n                        if (task.status === 'failed' &amp;&amp; task.error) {\n                            taskDiv.innerHTML += `&lt;p class=\"error\"&gt;Error: ${task.error}&lt;/p&gt;`;\n                        }\n\n                        // Add directory if available\n                        if (task.directory) {\n                            taskDiv.innerHTML += `&lt;p&gt;Directory: ${task.directory}&lt;/p&gt;`;\n                        }\n\n                        statusDiv.appendChild(taskDiv);\n                    }\n                });\n        }\n\n        // Update status every second\n        setInterval(updateStatus, 1000);\n\n        // Initial update\n        document.addEventListener('DOMContentLoaded', updateStatus);\n    &lt;/script&gt;\n    &lt;style&gt;\n        .task {\n            margin: 10px;\n            padding: 15px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .progress {\n            height: 20px;\n            background-color: #f5f5f5;\n            border-radius: 5px;\n            margin: 10px 0;\n        }\n        .progress-bar {\n            height: 100%;\n            background-color: #4CAF50;\n            text-align: center;\n            line-height: 20px;\n            color: white;\n            border-radius: 5px;\n        }\n        .error {\n            color: red;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Repository Clone Monitor&lt;/h1&gt;\n    &lt;div id=\"status\"&gt;Loading...&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n</code></pre>"},{"location":"api/clone-monitoring/#the-clonestatus-and-clonetask-classes","title":"The <code>CloneStatus</code> and <code>CloneTask</code> Classes","text":"<p>GitFleet provides two main classes for tracking clone operations:</p>"},{"location":"api/clone-monitoring/#clonestatus","title":"CloneStatus","text":"<pre><code>class CloneStatus:\n    status_type: str  # \"queued\", \"cloning\", \"completed\", or \"failed\"\n    progress: Optional[int]  # Percentage of completion (0-100) for \"cloning\" status\n    error: Optional[str]  # Error message for \"failed\" status\n</code></pre>"},{"location":"api/clone-monitoring/#clonetask","title":"CloneTask","text":"<pre><code>class CloneTask:\n    url: str  # Repository URL\n    status: CloneStatus  # Current status\n    temp_dir: Optional[str]  # Path to cloned repository (if completed)\n</code></pre>"},{"location":"api/clone-monitoring/#clone-notifications","title":"Clone Notifications","text":"<p>You can implement notifications for clone events:</p> <pre><code>import asyncio\nimport smtplib\nfrom email.message import EmailMessage\nfrom GitFleet import RepoManager\n\nasync def clone_with_notifications(repo_manager, email):\n    # Start cloning\n    clone_future = repo_manager.clone_all()\n\n    # Previous status to track changes\n    previous_status = {}\n\n    # Monitor until complete\n    while not clone_future.done():\n        # Get current status\n        clone_tasks = await repo_manager.fetch_clone_tasks()\n\n        # Check for status changes\n        for url, task in clone_tasks.items():\n            current_status = task.status.status_type\n\n            # If we haven't seen this task before or status changed\n            if url not in previous_status or previous_status[url] != current_status:\n                # Update previous status\n                previous_status[url] = current_status\n\n                # Send notification for completed or failed\n                if current_status in [\"completed\", \"failed\"]:\n                    send_notification(\n                        email,\n                        f\"Repository Clone {current_status.capitalize()}\",\n                        f\"The clone of {url} has {current_status}.\\n\" +\n                        (f\"Error: {task.status.error}\" if current_status == \"failed\" else \"\") +\n                        (f\"Directory: {task.temp_dir}\" if task.temp_dir else \"\")\n                    )\n\n        # Wait before checking again\n        await asyncio.sleep(5)\n\ndef send_notification(email, subject, message):\n    # Simple email notification\n    msg = EmailMessage()\n    msg.set_content(message)\n    msg['Subject'] = subject\n    msg['From'] = 'noreply@example.com'\n    msg['To'] = email\n\n    # Send email\n    with smtplib.SMTP('smtp.example.com', 587) as server:\n        server.starttls()\n        server.login('username', 'password')\n        server.send_message(msg)\n</code></pre>"},{"location":"api/clone-monitoring/#related-documentation","title":"Related Documentation","text":"<ul> <li>CloneStatus: Detailed documentation of the CloneStatus class</li> <li>CloneTask: Detailed documentation of the CloneTask class</li> <li>RepoManager: Main interface for repository operations</li> <li>Clone Monitoring Example: Complete example with clone monitoring</li> </ul>"},{"location":"development/architecture/","title":"GitFleet Architecture","text":"<p>This page provides an overview of GitFleet's architecture, explaining the design decisions, component interactions, and implementation details.</p>"},{"location":"development/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>GitFleet is built with a hybrid architecture that combines the performance of Rust with the convenience and ecosystem of Python:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Python Layer                          \u2502\n\u2502                                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 RepoManager   \u2502   \u2502 Provider APIs  \u2502   \u2502 Models      \u2502  \u2502\n\u2502  \u2502 Python API    \u2502   \u2502 (GitHub, etc.) \u2502   \u2502 (Pydantic)  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                          \u2502 PyO3\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       Rust Layer                           \u2502\n\u2502                                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 RepoManager   \u2502   \u2502 Git Operations \u2502   \u2502 Core Models \u2502  \u2502\n\u2502  \u2502 Implementation\u2502   \u2502 (blame, etc.)  \u2502   \u2502             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                          \u2502 FFI\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     External Resources                      \u2502\n\u2502                                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Local Git     \u2502   \u2502 GitHub API     \u2502   \u2502 File System \u2502  \u2502\n\u2502  \u2502 Repositories  \u2502   \u2502                \u2502   \u2502             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#rust-core-library","title":"Rust Core Library","text":"<p>The core functionality is implemented in Rust for maximum performance:</p> <ul> <li>Repository Manager: Manages repository cloning, cleanup, and operations</li> <li>Blame Engine: High-performance blame analysis</li> <li>Commit Extractor: Efficient commit history processing</li> <li>Clone Manager: Asynchronous repository cloning with progress tracking</li> </ul>"},{"location":"development/architecture/#key-rust-modules","title":"Key Rust Modules","text":"<ul> <li><code>src/lib.rs</code>: Main entrypoint and Python binding definitions</li> <li><code>src/repo.rs</code>: Repository management logic</li> <li><code>src/blame.rs</code>: Git blame implementation</li> <li><code>src/commits.rs</code>: Commit history extraction</li> <li><code>src/clone.rs</code>: Repository cloning with progress tracking</li> <li><code>src/token.rs</code>: Token management for API authentication</li> </ul>"},{"location":"development/architecture/#python-interface","title":"Python Interface","text":"<p>The Python interface provides a user-friendly API with additional features:</p> <ul> <li>Asyncio Integration: All operations are exposed as Python coroutines</li> <li>Pydantic Models: Type validation and serialization</li> <li>Provider APIs: Interfaces for Git hosting providers</li> <li>Pandas Integration: Convert results to DataFrames</li> </ul>"},{"location":"development/architecture/#key-python-modules","title":"Key Python Modules","text":"<ul> <li><code>GitFleet/__init__.py</code>: Main package exports</li> <li><code>GitFleet/models/</code>: Data models for repository operations</li> <li><code>GitFleet/providers/</code>: Provider API clients (GitHub, etc.)</li> <li><code>GitFleet/utils/</code>: Utility functions and helpers</li> </ul>"},{"location":"development/architecture/#concurrency-model","title":"Concurrency Model","text":"<p>GitFleet uses a hybrid concurrency model:</p> <ul> <li>Rust: Uses Tokio for asynchronous operations</li> <li>Python: Exposes asyncio coroutines for non-blocking operations</li> <li>Bridge: Uses pyo3-asyncio to bridge between Tokio and asyncio</li> </ul> <p>Operations that could block (like Git operations) are executed in separate threads to avoid blocking the main event loop.</p>"},{"location":"development/architecture/#memory-management","title":"Memory Management","text":"<p>GitFleet optimizes memory usage through:</p> <ul> <li>Rust Ownership: Ensures memory safety without garbage collection</li> <li>Arc Sharing: Shared resources use atomic reference counting</li> <li>Temporary Directories: Automatic cleanup of temporary clone directories</li> <li>Stream Processing: Large result sets are processed as streams, not loaded entirely in memory</li> </ul>"},{"location":"development/architecture/#error-handling","title":"Error Handling","text":"<p>Error handling is comprehensive:</p> <ul> <li>Rust Results: Functions return <code>Result&lt;T, E&gt;</code> for error handling</li> <li>Python Exceptions: Rust errors are converted to appropriate Python exceptions</li> <li>Status Objects: Operations provide status objects with detailed information</li> <li>Logging: Comprehensive logging throughout the codebase</li> </ul>"},{"location":"development/architecture/#testing-strategy","title":"Testing Strategy","text":"<p>GitFleet employs a multi-layered testing strategy:</p> <ul> <li>Rust Unit Tests: Test core functionality in isolation</li> <li>Python Unit Tests: Test Python-specific functionality</li> <li>Integration Tests: Test the full stack from Python to external systems</li> <li>Property-Based Tests: Test with randomized inputs for robustness</li> </ul>"},{"location":"development/architecture/#performance-optimizations","title":"Performance Optimizations","text":"<p>Several performance optimizations are employed:</p> <ul> <li>Parallel Processing: Multiple repositories processed concurrently</li> <li>Lazy Loading: Results loaded on demand to reduce memory usage</li> <li>Caching: Common operations are cached to avoid redundant work</li> <li>Native Implementation: Performance-critical code in Rust</li> <li>Tokio Runtime: Efficient task scheduler for concurrent operations</li> </ul>"},{"location":"development/architecture/#security-considerations","title":"Security Considerations","text":"<p>GitFleet prioritizes security:</p> <ul> <li>Token Management: Secure handling of API tokens</li> <li>Temporary Storage: Secure creation and cleanup of temporary directories</li> <li>Input Validation: Comprehensive validation of all inputs</li> <li>Safe Defaults: Conservative defaults for all operations</li> </ul>"},{"location":"development/architecture/#related-documentation","title":"Related Documentation","text":"<ul> <li>Python-Rust Bridge: Details on the PyO3 integration</li> <li>Contributing Guide: How to contribute to GitFleet</li> <li>Performance Tips: Tips for maximizing performance</li> </ul>"},{"location":"development/python-rust-bridge/","title":"Python-Rust Bridge","text":"<p>GitFleet uses a hybrid architecture with a Rust core and Python bindings through PyO3. This page explains how the Python-Rust bridge works and how to use it effectively.</p>"},{"location":"development/python-rust-bridge/#architecture-overview","title":"Architecture Overview","text":"<p>GitFleet's architecture consists of three main layers:</p> <ol> <li>Rust Core Library: High-performance, memory-safe implementation of Git operations</li> <li>PyO3 Bridge Layer: Exposes Rust functionality to Python with asyncio integration</li> <li>Python Interface: User-friendly API with additional Python-specific features</li> </ol>"},{"location":"development/python-rust-bridge/#how-pyo3-is-used-in-gitfleet","title":"How PyO3 is Used in GitFleet","text":"<p>The PyO3 library allows GitFleet to expose Rust functionality to Python in a way that feels natural to Python developers. Here's how it works:</p>"},{"location":"development/python-rust-bridge/#rust-struct-definitions-with-pyo3-annotations","title":"Rust Struct Definitions with PyO3 Annotations","text":"<pre><code>use pyo3::prelude::*;\n\n#[pyclass]\nstruct RepoManager {\n    urls: Vec&lt;String&gt;,\n    github_token: String,\n    // ...other fields\n}\n\n#[pymethods]\nimpl RepoManager {\n    #[new]\n    fn new(urls: Vec&lt;String&gt;, github_token: String) -&gt; Self {\n        RepoManager {\n            urls,\n            github_token,\n            // ...initialize other fields\n        }\n    }\n\n    fn clone_all(&amp;self, py: Python) -&gt; PyResult&lt;PyObject&gt; {\n        // Implementation of clone_all that returns a Python Future\n        // ...\n    }\n\n    // ...other methods\n}\n</code></pre>"},{"location":"development/python-rust-bridge/#async-bridge-with-pyo3-async-runtime","title":"Async Bridge with pyo3-async-runtime","text":"<p>GitFleet uses pyo3-asyncio to bridge between Rust's async model (Tokio) and Python's asyncio:</p> <pre><code>use pyo3::prelude::*;\nuse pyo3_asyncio::tokio::future_into_py;\n\n#[pymethods]\nimpl RepoManager {\n    fn clone_all&lt;'p&gt;(&amp;self, py: Python&lt;'p&gt;) -&gt; PyResult&lt;&amp;'p PyAny&gt; {\n        let urls = self.urls.clone();\n        let github_token = self.github_token.clone();\n\n        // Create a Rust future\n        let fut = async move {\n            // Clone repositories asynchronously with tokio\n            // ...\n            Ok(Python::with_gil(|py| {\n                // Convert result to Python object\n                // ...\n            })?)\n        };\n\n        // Convert Rust future to Python future\n        future_into_py(py, fut)\n    }\n}\n</code></pre>"},{"location":"development/python-rust-bridge/#exposed-rust-api","title":"Exposed Rust API","text":"<p>The following Rust modules are exposed to Python:</p> Rust Module Python Module Description <code>src/repo.rs</code> <code>GitFleet.RepoManager</code> Repository management <code>src/clone.rs</code> <code>GitFleet.models.repo</code> Clone operations <code>src/blame.rs</code> <code>GitFleet.models.repo</code> Blame functionality <code>src/commits.rs</code> <code>GitFleet.models.repo</code> Commit extraction <code>src/token.rs</code> <code>GitFleet.providers.token_manager</code> Token management"},{"location":"development/python-rust-bridge/#data-conversion-between-python-and-rust","title":"Data Conversion Between Python and Rust","text":"<p>GitFleet handles data conversion between Python and Rust transparently:</p>"},{"location":"development/python-rust-bridge/#python-to-rust","title":"Python to Rust","text":"<ul> <li>Python strings \u2192 Rust <code>String</code></li> <li>Python lists \u2192 Rust <code>Vec&lt;T&gt;</code></li> <li>Python dicts \u2192 Rust <code>HashMap&lt;K, V&gt;</code> or custom structs</li> <li>Python None \u2192 Rust <code>Option&lt;T&gt;</code> as <code>None</code></li> </ul>"},{"location":"development/python-rust-bridge/#rust-to-python","title":"Rust to Python","text":"<ul> <li>Rust <code>String</code> \u2192 Python strings</li> <li>Rust <code>Vec&lt;T&gt;</code> \u2192 Python lists</li> <li>Rust <code>HashMap&lt;K, V&gt;</code> \u2192 Python dicts</li> <li>Rust structs \u2192 Python dataclasses or dicts</li> <li>Rust <code>Result&lt;T, E&gt;</code> \u2192 Python return value or exception</li> <li>Rust <code>Option&lt;T&gt;</code> \u2192 Python value or None</li> </ul>"},{"location":"development/python-rust-bridge/#fallback-to-python-implementation","title":"Fallback to Python Implementation","text":"<p>For flexibility, GitFleet provides a pure Python implementation that can be used when the Rust implementation is not available or when explicitly requested:</p> <pre><code>from GitFleet import RepoManager\n\n# Use Rust implementation (default)\nrepo_manager = RepoManager(urls=[\"https://github.com/user/repo\"])\n\n# Force Python implementation\npython_repo_manager = RepoManager(\n    urls=[\"https://github.com/user/repo\"],\n    use_python_impl=True\n)\n</code></pre>"},{"location":"development/python-rust-bridge/#performance-considerations","title":"Performance Considerations","text":"<p>The Rust implementation offers significant performance benefits:</p> <ul> <li>Memory Efficiency: Rust's ownership model reduces memory usage</li> <li>Processing Speed: Blame and commit analysis is typically 5-10x faster in Rust</li> <li>Concurrency: Tokio's work-stealing scheduler efficiently handles many repositories</li> <li>GIL Avoidance: Compute-intensive operations run outside Python's GIL</li> </ul>"},{"location":"development/python-rust-bridge/#contributing-to-the-bridge-layer","title":"Contributing to the Bridge Layer","text":"<p>When contributing to the Python-Rust bridge:</p> <ol> <li>Make changes to the Rust implementation first</li> <li>Update the PyO3 bindings to expose the new functionality</li> <li>Update the Python interface to match</li> <li>Test both implementations (Rust and pure Python)</li> <li>Document any differences in behavior between implementations</li> </ol>"},{"location":"development/python-rust-bridge/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview</li> <li>Contributing Guide</li> <li>Performance Tips</li> </ul>"},{"location":"examples/basic-usage/","title":"Basic Usage Example","text":"<p>This example demonstrates the fundamental operations of GitFleet, including initializing a repository manager, cloning repositories, monitoring clone status, and analyzing repository data.</p>"},{"location":"examples/basic-usage/#code-example","title":"Code Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nGitFleet Basic Usage Example\n\nThis example demonstrates how to use the GitFleet library to:\n1. Initialize a repository manager\n2. Clone repositories\n3. Check clone statuses\n4. Analyze blame information\n5. Analyze commit history\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom GitFleet import RepoManager\n\n# GitHub credentials - replace with your own or use environment variables\nGITHUB_USERNAME = os.environ.get(\"GITHUB_USERNAME\", \"your-username\")\nGITHUB_TOKEN = os.environ.get(\"GITHUB_TOKEN\", \"your-personal-access-token\")\n\n# Repository URLs to analyze\nREPO_URLS = [\n    # Example - you can change to your repositories\n    \"https://github.com/bmeddeb/gradelib\",\n]\n\n\nasync def main():\n    # Initialize the repository manager\n    print(\"Initializing repository manager...\")\n    repo_manager = RepoManager(\n        urls=REPO_URLS, github_username=GITHUB_USERNAME, github_token=GITHUB_TOKEN\n    )\n\n    # Start cloning repositories asynchronously\n    print(f\"Starting clone of {len(REPO_URLS)} repositories...\")\n    # PyO3 already returns futures, not coroutines\n    clone_future = repo_manager.clone_all()\n\n    # Monitor cloning progress with a more detailed display\n    try:\n        # Continue monitoring until all repos are done (completed or failed)\n        previous_status = {}\n        while not clone_future.done():\n            # Get current status of all clone tasks\n            clone_tasks = await repo_manager.fetch_clone_tasks()\n\n            # Check if there are any active clones\n            all_done = True\n\n            # Clear terminal if supported (not on Windows)\n            if os.name != \"nt\":\n                os.system(\"clear\")\n            else:\n                os.system(\"cls\")\n\n            print(\"\\n===== REPOSITORY CLONE STATUS =====\\n\")\n\n            for url, task in clone_tasks.items():\n                status = task.status.status_type\n                progress = task.status.progress\n\n                # Status indicator\n                status_indicator = {\n                    \"queued\": \"\u231b QUEUED\",\n                    \"cloning\": \"\ud83d\udd04 CLONING\",\n                    \"completed\": \"\u2705 COMPLETED\",\n                    \"failed\": \"\u274c FAILED\",\n                }.get(status, status.upper())\n\n                # Print repository info\n                print(f\"Repository: {url}\")\n                print(f\"Status: {status_indicator}\")\n\n                # Show progress bar for cloning status\n                if status == \"cloning\" and progress is not None:\n                    bar_length = 30\n                    filled_length = int(bar_length * progress / 100)\n                    bar = \"\u2588\" * filled_length + \"\u2591\" * (bar_length - filled_length)\n                    print(f\"Progress: [{bar}] {progress}%\")\n\n                    # Print a message when progress changes significantly\n                    prev_progress = 0\n                    if (\n                        url in previous_status\n                        and previous_status[url][\"status\"] == \"cloning\"\n                    ):\n                        prev_progress = previous_status[url][\"progress\"] or 0\n\n                    if progress - prev_progress &gt;= 10:\n                        print(f\"  \u2191 Progress increased by {progress - prev_progress}%\")\n\n                # Show error if failed\n                if status == \"failed\" and task.status.error:\n                    print(f\"Error: {task.status.error}\")\n\n                # Show clone directory if available\n                if task.temp_dir:\n                    print(f\"Directory: {task.temp_dir}\")\n\n                # Update status tracking\n                previous_status[url] = {\"status\": status, \"progress\": progress}\n\n                # Check if we need to continue monitoring\n                if status not in [\"completed\", \"failed\"]:\n                    all_done = False\n\n                print(\"-\" * 50)\n\n            # Exit loop if all done\n            if all_done:\n                break\n\n            # Wait before refreshing\n            await asyncio.sleep(1)\n\n        # Make sure the clone_all task completes\n        await clone_future\n\n    except KeyboardInterrupt:\n        print(\n            \"\\nMonitoring interrupted. Clone operations may continue in the background.\"\n        )\n\n    print(\"\\nAll clone operations completed or failed.\")\n\n    # Find a successfully cloned repository to analyze\n    repo_path = None\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n    for _, task in clone_tasks.items():\n        if task.status.status_type == \"completed\" and task.temp_dir:\n            repo_path = task.temp_dir\n            break\n\n    if not repo_path:\n        print(\"No repositories were cloned successfully.\")\n        return\n\n    # Analyze blame for a few files in the repository\n    print(f\"\\nAnalyzing blame information for files in {repo_path}...\")\n    # Find Python files in the repository (adjust for your specific case)\n    file_paths = []\n    for root, _, files in os.walk(repo_path):\n        for file in files:\n            if file.endswith(\".py\"):\n                file_paths.append(\n                    os.path.join(root, file).replace(repo_path + os.sep, \"\")\n                )\n                if len(file_paths) &gt;= 3:  # Limit to 3 files for this example\n                    break\n        if len(file_paths) &gt;= 3:\n            break\n\n    if file_paths:\n        print(f\"Analyzing blame for {len(file_paths)} files...\")\n        blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n        for file_path, blame_info in blame_results.items():\n            if isinstance(blame_info, list):  # Success case\n                print(f\"\\nBlame summary for {file_path}:\")\n                authors = {}\n                for line in blame_info:\n                    author = line[\"author_name\"]\n                    if author in authors:\n                        authors[author] += 1\n                    else:\n                        authors[author] = 1\n\n                print(\"Top contributors:\")\n                for author, count in sorted(\n                    authors.items(), key=lambda x: x[1], reverse=True\n                )[:3]:\n                    print(f\"  {author}: {count} lines\")\n            else:  # Error case\n                print(f\"Error analyzing {file_path}: {blame_info}\")\n\n    # Analyze commit history\n    print(\"\\nAnalyzing commit history...\")\n    commits = await repo_manager.extract_commits(repo_path)\n\n    if isinstance(commits, list):  # Success case\n        print(f\"Found {len(commits)} commits\")\n\n        # Show the 5 most recent commits\n        print(\"\\nRecent commits:\")\n        for commit in commits[:5]:\n            print(f\"Commit: {commit['sha'][:7]}\")\n            print(f\"Author: {commit['author_name']}\")\n            print(f\"Date: {commit['author_timestamp']}\")\n            message_summary = commit[\"message\"].split(\"\\n\")[0][:50]\n            print(f\"Message: {message_summary}...\")\n            print(f\"Changes: +{commit['additions']} -{commit['deletions']}\")\n            print(\"\")\n    else:  # Error case\n        print(f\"Error analyzing commits: {commits}\")\n\n\nif __name__ == \"__main__\":\n    # Set up the event loop and run the main async function\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic-usage/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several key features of GitFleet:</p> <ol> <li>Repository Management: Initializing and configuring a <code>RepoManager</code> instance</li> <li>Asynchronous Cloning: Non-blocking repository cloning with a future-based API</li> <li>Clone Progress Monitoring: Tracking the progress of clone operations with detailed status information</li> <li>Blame Analysis: Extracting and summarizing blame information for files</li> <li>Commit History Analysis: Extracting and analyzing commit history information</li> </ol>"},{"location":"examples/basic-usage/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install GitFleet using pip:    <pre><code>pip install gitfleet\n</code></pre></p> </li> <li> <p>Set your GitHub credentials as environment variables:    <pre><code>export GITHUB_USERNAME=your-username\nexport GITHUB_TOKEN=your-personal-access-token\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>python examples/basic_usage.py\n</code></pre></p> </li> </ol>"},{"location":"examples/basic-usage/#related-examples","title":"Related Examples","text":"<ul> <li>Clone Monitoring: More advanced techniques for monitoring clone operations</li> <li>GitHub Client: Working with the GitHub API client</li> </ul>"},{"location":"providers/","title":"Git Provider API Clients","text":"<p>GitFleet includes API clients for various Git hosting providers that allow you to interact with repositories, users, and other provider-specific information.</p>"},{"location":"providers/#available-providers","title":"Available Providers","text":"<p>The following providers are currently implemented:</p> <ul> <li>GitHub: Complete API client for GitHub with support for repositories, users, branches, and more.</li> </ul> <p>Coming soon: - GitLab: API client for GitLab (planned for v0.4.0) - BitBucket: API client for BitBucket (planned for v0.5.0)</p>"},{"location":"providers/#key-features","title":"Key Features","text":"<ul> <li>Data Models: Type-safe dataclasses for all provider data</li> <li>Dual Implementation: Both Rust and Python implementations</li> <li>Token Management: Built-in token rotation and rate limit handling </li> <li>Error Handling: Comprehensive error hierarchy for all providers</li> <li>Async Support: Full async/await support for concurrent operations</li> <li>Pandas Integration: Easy conversion to pandas DataFrames</li> </ul>"},{"location":"providers/#common-features","title":"Common Features","text":"<p>All provider clients share a common interface through the <code>GitProviderClient</code> base class, making it easy to work with different providers using the same code patterns.</p> <p>Common functionality includes:</p> <ul> <li>Repository information retrieval</li> <li>User data access</li> <li>Branch and contributor details</li> <li>Rate limit handling</li> </ul>"},{"location":"providers/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom GitFleet import GitHubClient\n\nasync def main():\n    # Initialize the client with your token\n    # Will automatically use Rust implementation if available\n    github = GitHubClient(token=\"your-github-token\")\n\n    # Fetch repositories for a user\n    repos = await github.fetch_repositories(\"octocat\")\n\n    # Get user information (returns UserInfo dataclass)\n    user = await github.fetch_user_info()\n\n    # Check rate limits (returns RateLimitInfo dataclass)\n    rate_limit = await github.get_rate_limit()\n\n    # Work with typed dataclass objects\n    print(f\"Found {len(repos)} repositories\")\n    print(f\"Authenticated as: {user.login} ({user.name})\")\n    print(f\"API calls remaining: {rate_limit.remaining}/{rate_limit.limit}\")\n\n    # Explore repository details\n    for repo in repos[:3]:  # First 3 repos\n        print(f\"\\nRepository: {repo.full_name}\")\n        print(f\"  Description: {repo.description}\")\n        print(f\"  Language: {repo.language}\")\n        print(f\"  Stars: {repo.stargazers_count}\")\n        print(f\"  Forks: {repo.forks_count}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"providers/#token-management","title":"Token Management","text":"<p>GitFleet includes a built-in <code>TokenManager</code> for handling rate limits and authentication across multiple tokens:</p> <pre><code>from GitFleet import GitHubClient\nfrom GitFleet.providers import TokenManager, ProviderType\n\n# Create a token manager\ntoken_manager = TokenManager()\ntoken_manager.add_token(\"token1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"token2\", ProviderType.GITHUB)\n\n# Create a client with the token manager\ngithub = GitHubClient(\n    token=\"token1\",\n    token_manager=token_manager  # Auto-rotation of tokens\n)\n\n# The client will automatically use the next available token\n# when rate limits are hit\nrepos = await github.fetch_repositories(\"octocat\")\n</code></pre> <p>See the Token Management guide for more details.</p>"},{"location":"providers/#data-analysis-with-pandas","title":"Data Analysis with Pandas","text":"<p>All provider clients support converting their responses to pandas DataFrames for data analysis:</p> <pre><code># Option 1: Use the utility function\nfrom GitFleet import to_dataframe\nrepos = await github.fetch_repositories(\"octocat\")\ndf = to_dataframe(repos)\n\n# Option 2: Use the client method\nrepos = await github.fetch_repositories(\"octocat\")\ndf = await github.to_pandas(repos)\n\n# Analyze the data\npopular_repos = df.sort_values(\"stargazers_count\", ascending=False)\nlanguages = df[\"language\"].value_counts()\n\n# Print the top 5 most popular repositories\nprint(popular_repos[[\"name\", \"stargazers_count\"]].head(5))\n</code></pre>"},{"location":"providers/#force-python-implementation","title":"Force Python Implementation","text":"<p>You can force GitFleet to use the pure Python implementation if needed:</p> <pre><code># Force Python implementation\ngithub = GitHubClient(\n    token=\"your-github-token\",\n    use_python_impl=True  # Force Python implementation\n)\n</code></pre> <p>See the Implementation guide for more details.</p>"},{"location":"providers/github/","title":"GitHub API Client","text":"<p>The GitFleet GitHub API client provides a convenient interface to interact with the GitHub API. This client allows you to fetch repository information, user data, and other GitHub-specific resources.</p>"},{"location":"providers/github/#installation","title":"Installation","text":"<p>The GitHub client is included with GitFleet. No additional installation is required.</p> <pre><code>from GitFleet import GitHubClient\n</code></pre>"},{"location":"providers/github/#authentication","title":"Authentication","text":"<p>Initialize the client with your GitHub personal access token:</p> <pre><code>github = GitHubClient(token=\"your-github-token\")\n</code></pre> <p>You can create a token on GitHub at https://github.com/settings/tokens.</p> <p>For GitHub Enterprise, you can specify a custom base URL:</p> <pre><code>github = GitHubClient(\n    token=\"your-github-token\",\n    base_url=\"https://github.your-company.com/api/v3\"\n)\n</code></pre>"},{"location":"providers/github/#basic-usage","title":"Basic Usage","text":""},{"location":"providers/github/#fetch-repositories","title":"Fetch Repositories","text":"<p>Retrieve repositories for a user or organization:</p> <pre><code># Get repositories for a user (returns a List[RepoInfo])\nrepos = await github.fetch_repositories(\"octocat\")\n\n# Print repository names using dataclass attributes\nfor repo in repos:\n    print(f\"{repo.full_name} - {repo.description}\")\n    print(f\"  Stars: {repo.stargazers_count}, Language: {repo.language}\")\n</code></pre>"},{"location":"providers/github/#user-information","title":"User Information","text":"<p>Get information about the authenticated user:</p> <pre><code># Returns UserInfo dataclass\nuser = await github.fetch_user_info()\nprint(f\"Authenticated as: {user.login}\")\nprint(f\"Name: {user.name}\")\nprint(f\"Email: {user.email}\")\nprint(f\"Avatar URL: {user.avatar_url}\")\n</code></pre>"},{"location":"providers/github/#repository-details","title":"Repository Details","text":"<p>Fetch detailed information about a specific repository:</p> <pre><code># Returns RepoDetails dataclass\nrepo = await github.fetch_repository_details(\"octocat\", \"hello-world\")\nprint(f\"Description: {repo.description}\")\nprint(f\"Topics: {', '.join(repo.topics)}\")\nprint(f\"License: {repo.license}\")\nprint(f\"Created: {repo.created_at}\")\nprint(f\"Updated: {repo.updated_at}\")\nprint(f\"Has Wiki: {repo.has_wiki}\")\n</code></pre>"},{"location":"providers/github/#contributors-and-branches","title":"Contributors and Branches","text":"<p>Get contributors for a repository:</p> <pre><code># Returns List[ContributorInfo]\ncontributors = await github.fetch_contributors(\"octocat\", \"hello-world\")\nfor contributor in contributors:\n    print(f\"{contributor.login} - {contributor.contributions} contributions\")\n    print(f\"  User ID: {contributor.id}\")\n</code></pre> <p>Get branches for a repository:</p> <pre><code># Returns List[BranchInfo]\nbranches = await github.fetch_branches(\"octocat\", \"hello-world\")\nfor branch in branches:\n    protected = \"Protected\" if branch.protected else \"Not protected\"\n    print(f\"{branch.name} - {protected}\")\n    print(f\"  Commit SHA: {branch.commit_sha}\")\n</code></pre>"},{"location":"providers/github/#rate-limits","title":"Rate Limits","text":"<p>Check your current rate limit status:</p> <pre><code># Returns RateLimitInfo dataclass\nrate_limit = await github.get_rate_limit()\nprint(f\"API calls remaining: {rate_limit.remaining}/{rate_limit.limit}\")\nprint(f\"Reset time: {rate_limit.reset_time}\")\nprint(f\"Used: {rate_limit.used}\")\n</code></pre>"},{"location":"providers/github/#implementation-selection","title":"Implementation Selection","text":"<p>You can choose between the Rust and Python implementations:</p> <pre><code># Default: Use Rust implementation if available, fall back to Python\ngithub = GitHubClient(token=\"your-token\")\n\n# Force Python implementation\ngithub_py = GitHubClient(\n    token=\"your-token\",\n    use_python_impl=True\n)\n\n# Check which implementation is being used\nif hasattr(github, \"_use_rust\"):\n    print(f\"Using Rust implementation: {github._use_rust}\")\n</code></pre>"},{"location":"providers/github/#error-handling","title":"Error Handling","text":"<p>The GitHub client includes a comprehensive error hierarchy:</p> <pre><code>from GitFleet.providers.base import ProviderError, AuthError, RateLimitError\n\ntry:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept AuthError as e:\n    print(f\"Authentication error: {e}\")\n    print(f\"Provider type: {e.provider_type}\")  # Will be ProviderType.GITHUB\nexcept RateLimitError as e:\n    print(f\"Rate limit exceeded. Resets at: {e.reset_time}\")\n    print(f\"Provider type: {e.provider_type}\")  # Will be ProviderType.GITHUB\nexcept ProviderError as e:\n    print(f\"Provider error: {e}\")\n    print(f\"Provider type: {e.provider_type}\")  # Will be ProviderType.GITHUB\n</code></pre> <p>You can also use provider-specific error classes:</p> <pre><code>from GitFleet.providers.github import GitHubError\n\ntry:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept GitHubError as e:\n    print(f\"GitHub error: {e}\")\n</code></pre> <p>The error hierarchy is as follows:</p> <pre><code>Exception\n\u2514\u2500\u2500 ProviderError (base.py)\n    \u251c\u2500\u2500 AuthError (base.py)\n    \u251c\u2500\u2500 RateLimitError (base.py)\n    \u2514\u2500\u2500 GitHubError (github.py)\n</code></pre>"},{"location":"providers/github/#data-analysis-with-pandas","title":"Data Analysis with Pandas","text":"<p>Convert API response data to pandas DataFrames for analysis:</p> <pre><code># Method 1: Using utility function (recommended)\nfrom GitFleet import to_dataframe\n\nrepos = await github.fetch_repositories(\"octocat\")\ndf = to_dataframe(repos)\n\n# Method 2: Using client method\nrepos = await github.fetch_repositories(\"octocat\")\ndf = await github.to_pandas(repos)\n\n# Analyze the data\nprint(f\"Most popular repositories (by stars):\")\npopular_repos = df.sort_values(\"stargazers_count\", ascending=False)\nprint(popular_repos[[\"name\", \"stargazers_count\", \"forks_count\"]].head())\n\n# Language distribution\nprint(\"\\nLanguage distribution:\")\nprint(df[\"language\"].value_counts())\n\n# Filter by attributes\npython_repos = df[df[\"language\"] == \"Python\"]\nprint(f\"\\nPython repositories: {len(python_repos)}\")\n\n# Advanced queries\nactive_repos = df[(df[\"updated_at\"] &gt; \"2023-01-01\") &amp; (df[\"fork\"] == False)]\nprint(f\"\\nActive non-fork repos since 2023: {len(active_repos)}\")\n</code></pre>"},{"location":"providers/github/#working-with-contributors","title":"Working with Contributors","text":"<pre><code>contributors = await github.fetch_contributors(\"octocat\", \"hello-world\")\ncontributors_df = to_dataframe(contributors)\n\n# Find top contributors\ntop_contributors = contributors_df.sort_values(\"contributions\", ascending=False)\nprint(top_contributors[[\"login\", \"contributions\"]].head(10))\n</code></pre>"},{"location":"providers/github/#customizing-dataframe-conversion","title":"Customizing DataFrame Conversion","text":"<p>You can customize the DataFrame conversion by accessing the raw data:</p> <pre><code>repos = await github.fetch_repositories(\"octocat\")\n\n# Custom conversion with selected fields\nimport pandas as pd\ncustom_data = [\n    {\n        \"repo_name\": repo.name,\n        \"stars\": repo.stargazers_count or 0,\n        \"is_popular\": (repo.stargazers_count or 0) &gt; 100,\n        \"lang\": repo.language or \"Unknown\"\n    }\n    for repo in repos\n]\ncustom_df = pd.DataFrame(custom_data)\n</code></pre>"},{"location":"providers/github/#pagination","title":"Pagination","text":"<p>The GitHub client automatically handles pagination. You don't need to worry about pagination limits as the client will fetch all available results.</p>"},{"location":"providers/implementation/","title":"Dual Implementation Architecture","text":"<p>GitFleet supports both Rust-based and pure Python implementations for its Git provider APIs. This architecture provides performance benefits when the Rust components are available, with a fallback to a pure Python implementation for maximum compatibility.</p>"},{"location":"providers/implementation/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Python Interface           \u2502\n\u2502                                       \u2502\n\u2502         GitProviderClient (ABC)       \u2502\n\u2502                  \u2502                    \u2502\n\u2502                  \u25bc                    \u2502\n\u2502          Specific Providers           \u2502\n\u2502     (GitHubClient, GitLabClient)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Rust     \u2502         \u2502    Python     \u2502\n\u2502 Backend   \u2502         \u2502   Backend     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"providers/implementation/#implementation-detection","title":"Implementation Detection","text":"<p>When you create a provider client (like <code>GitHubClient</code>), GitFleet automatically detects if the Rust implementation is available:</p> <pre><code>from GitFleet import GitHubClient\n\n# The client will use Rust implementation if available,\n# otherwise it will fall back to Python\nclient = GitHubClient(token=\"your-token\")\n</code></pre>"},{"location":"providers/implementation/#forcing-python-implementation","title":"Forcing Python Implementation","text":"<p>You can force GitFleet to use the Python implementation even when Rust is available:</p> <pre><code># Force Python implementation\nclient = GitHubClient(\n    token=\"your-token\",\n    use_python_impl=True\n)\n</code></pre> <p>This can be useful for: - Debugging - Ensuring consistent behavior across environments - When you need features only available in the Python implementation</p>"},{"location":"providers/implementation/#checking-implementation-status","title":"Checking Implementation Status","text":"<p>You can check which implementation is being used:</p> <pre><code>from GitFleet import GitHubClient\n\nclient = GitHubClient(token=\"your-token\")\n\n# Check if Rust implementation is available\nprint(f\"Rust available: {client._use_rust}\")\n</code></pre>"},{"location":"providers/implementation/#implementation-differences","title":"Implementation Differences","text":"<p>Both implementations provide the same interface and functionality, but there are some differences:</p>"},{"location":"providers/implementation/#performance","title":"Performance","text":"<p>The Rust implementation typically offers: - Faster request processing - More efficient memory usage - Better handling of concurrent requests</p>"},{"location":"providers/implementation/#features","title":"Features","text":"<p>The Python implementation may offer: - More granular control over HTTP requests - Easier debugging and customization - Additional helper methods in some cases</p>"},{"location":"providers/implementation/#error-handling","title":"Error Handling","text":"<p>Both implementations use the same error types, but error messages may differ slightly. The Python implementation provides more detailed error messages in some cases, while the Rust implementation typically provides more precise error codes.</p>"},{"location":"providers/implementation/#switching-at-runtime","title":"Switching at Runtime","text":"<p>You cannot switch implementations on an existing client instance. If you need to switch, create a new client:</p> <pre><code># Start with Rust implementation\nrust_client = GitHubClient(token=\"your-token\")\n\n# Later, create a Python implementation if needed\npython_client = GitHubClient(token=\"your-token\", use_python_impl=True)\n</code></pre>"},{"location":"providers/implementation/#token-management","title":"Token Management","text":"<p>Both implementations support the TokenManager for handling multiple tokens and rate limits:</p> <pre><code>from GitFleet import GitHubClient\nfrom GitFleet.providers import TokenManager\n\n# Create a token manager\ntoken_manager = TokenManager()\ntoken_manager.add_token(\"token1\", \"github\")\ntoken_manager.add_token(\"token2\", \"github\")\n\n# Use with Rust or Python implementation\nclient = GitHubClient(\n    token=\"token1\",\n    token_manager=token_manager\n)\n</code></pre>"},{"location":"providers/implementation/#implementation-details","title":"Implementation Details","text":""},{"location":"providers/implementation/#rust-implementation","title":"Rust Implementation","text":"<p>The Rust implementation: - Uses the <code>reqwest</code> crate for HTTP requests - Implements efficient serialization with <code>serde</code> - Uses Tokio for async runtime - Leverages Rust's memory safety and performance optimizations</p>"},{"location":"providers/implementation/#python-implementation","title":"Python Implementation","text":"<p>The Python implementation: - Uses <code>httpx</code> for async HTTP requests - Provides detailed error messages and debugging - Has no native dependencies besides Python's standard library - Provides fully typed interfaces with dataclasses</p>"},{"location":"providers/implementation/#future-compatibility","title":"Future Compatibility","text":"<p>As GitFleet evolves: - Both implementations will maintain API compatibility - New features will be added to both implementations when possible - The Rust implementation will continue to focus on performance - The Python implementation will focus on flexibility and integration</p>"},{"location":"providers/models/","title":"Provider Data Models","text":"<p>GitFleet uses standardized data models across all Git provider APIs. These models provide consistent data structures regardless of which provider (GitHub, GitLab, BitBucket) you are working with.</p>"},{"location":"providers/models/#core-data-models","title":"Core Data Models","text":"<p>All data models are implemented as Python dataclasses, providing type hints, autocompletion, and better IDE integration.</p>"},{"location":"providers/models/#repository-information","title":"Repository Information","text":"<pre><code>@dataclass\nclass RepoInfo:\n    \"\"\"Common repository information structure.\"\"\"\n    name: str                     # Repository name\n    full_name: str                # Full name (owner/repo)\n    clone_url: str                # Git clone URL\n    description: Optional[str]    # Repository description\n    default_branch: str           # Default branch name\n    created_at: str               # Creation timestamp\n    updated_at: str               # Last update timestamp\n    language: Optional[str]       # Primary language\n    fork: bool                    # Whether it's a fork\n    forks_count: int              # Number of forks\n    stargazers_count: Optional[int] # Number of stars\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n    visibility: str               # Visibility (public/private)\n    owner: Dict[str, Any]         # Owner information\n    raw_data: Optional[Dict[str, Any]] = None  # Raw provider data\n</code></pre>"},{"location":"providers/models/#user-information","title":"User Information","text":"<pre><code>@dataclass\nclass UserInfo:\n    \"\"\"User information structure.\"\"\"\n    id: str                       # User ID\n    login: str                    # Username/login\n    name: Optional[str]           # Full name\n    email: Optional[str]          # Email address\n    avatar_url: Optional[str]     # Avatar URL\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n    raw_data: Optional[Dict[str, Any]] = None  # Raw provider data\n</code></pre>"},{"location":"providers/models/#rate-limit-information","title":"Rate Limit Information","text":"<pre><code>@dataclass\nclass RateLimitInfo:\n    \"\"\"Rate limit information structure.\"\"\"\n    limit: int                    # Total request limit\n    remaining: int                # Remaining requests\n    reset_time: int               # Reset timestamp\n    used: int                     # Used requests count\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n</code></pre>"},{"location":"providers/models/#detailed-repository-information","title":"Detailed Repository Information","text":"<pre><code>@dataclass\nclass RepoDetails(RepoInfo):\n    \"\"\"Detailed repository information structure.\"\"\"\n    topics: List[str]             # Repository topics/tags\n    license: Optional[str]        # License information\n    homepage: Optional[str]       # Homepage URL\n    has_wiki: bool                # Whether repo has wiki\n    has_issues: bool              # Whether repo has issues\n    has_projects: bool            # Whether repo has projects\n    archived: bool                # Whether repo is archived\n    pushed_at: Optional[str]      # Last push timestamp\n    size: int                     # Repository size\n</code></pre>"},{"location":"providers/models/#contributor-information","title":"Contributor Information","text":"<pre><code>@dataclass\nclass ContributorInfo:\n    \"\"\"Contributor information structure.\"\"\"\n    login: str                    # Username\n    id: str                       # User ID\n    avatar_url: Optional[str]     # Avatar URL\n    contributions: int            # Number of contributions\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n</code></pre>"},{"location":"providers/models/#branch-information","title":"Branch Information","text":"<pre><code>@dataclass\nclass BranchInfo:\n    \"\"\"Branch information structure.\"\"\"\n    name: str                     # Branch name\n    commit_sha: str               # Latest commit SHA\n    protected: bool               # Whether branch is protected\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n</code></pre>"},{"location":"providers/models/#working-with-models","title":"Working with Models","text":""},{"location":"providers/models/#direct-access","title":"Direct Access","text":"<p>Each model provides direct attribute access:</p> <pre><code># Get repositories for a user\nrepos = await github.fetch_repositories(\"octocat\")\n\n# Access model attributes directly\nfor repo in repos:\n    print(f\"Repository: {repo.full_name}\")\n    print(f\"Description: {repo.description}\")\n    print(f\"Stars: {repo.stargazers_count}\")\n</code></pre>"},{"location":"providers/models/#conversion-to-pandas-dataframes","title":"Conversion to Pandas DataFrames","text":"<p>All models can be converted to pandas DataFrames for data analysis:</p> <pre><code># Import pandas converter\nfrom GitFleet import to_dataframe\n\n# Get repositories for a user\nrepos = await github.fetch_repositories(\"octocat\")\n\n# Convert to DataFrame\ndf = to_dataframe(repos)\n\n# Analyze the data\ntop_repos = df.sort_values(\"stargazers_count\", ascending=False).head(10)\nlanguage_distribution = df[\"language\"].value_counts()\n</code></pre> <p>You can also use a client-specific method:</p> <pre><code>repos = await github.fetch_repositories(\"octocat\")\ndf = await github.to_pandas(repos)\n</code></pre>"},{"location":"providers/models/#raw-provider-data","title":"Raw Provider Data","text":"<p>Each model includes the original provider data for advanced use cases:</p> <pre><code>repo = await github.fetch_repository_details(\"octocat\", \"hello-world\")\n\n# Access standardized fields\nprint(repo.stargazers_count)\n\n# Access raw provider data for GitHub-specific fields\nif repo.raw_data and \"allow_forking\" in repo.raw_data:\n    print(f\"Allows forking: {repo.raw_data['allow_forking']}\")\n</code></pre>"},{"location":"providers/models/#error-handling","title":"Error Handling","text":"<p>When working with provider models, you may encounter provider-specific errors:</p> <pre><code>from GitFleet.providers.base import ProviderError, AuthError, RateLimitError\n\ntry:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept AuthError as e:\n    print(f\"Authentication error: {e}\")\nexcept RateLimitError as e:\n    print(f\"Rate limit exceeded. Resets at: {e.reset_time}\")\nexcept ProviderError as e:\n    print(f\"Provider error: {e}\")\n</code></pre>"},{"location":"providers/models/#provider-type-enumeration","title":"Provider Type Enumeration","text":"<p>The <code>ProviderType</code> enumeration is used to identify which provider a model belongs to:</p> <pre><code>from GitFleet.providers import ProviderType\n\n# Check the provider type\nrepos = await github.fetch_repositories(\"octocat\")\nif repos[0].provider_type == ProviderType.GITHUB:\n    print(\"This is a GitHub repository\")\n</code></pre> <p>Available provider types: - <code>ProviderType.GITHUB</code> - <code>ProviderType.GITLAB</code> (coming soon) - <code>ProviderType.BITBUCKET</code> (coming soon)</p>"}]}